diff --git a/include/v8.h b/include/v8.h
index 44de97e..9b026d2 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -1665,6 +1665,12 @@ struct SampleInfo {
                                   // executing an external callback.
 };
 
+// 2018-01-29
+struct V8InternalInfo {
+	size_t max_stack_size;//byte
+	size_t remain_stack_size;//byte
+};
+
 /**
  * A JSON Parser and Stringifier.
  */
@@ -6694,6 +6700,12 @@ class V8_EXPORT Isolate {
    */
   void GetHeapStatistics(HeapStatistics* heap_statistics);
 
+  /**
+  * 2018-01-29
+  *
+  */
+  void GetV8InternalInfo(V8InternalInfo &internal_info);
+
   /**
    * Returns the number of spaces in the heap.
    */
diff --git a/samples/adsafe.js b/samples/adsafe.js
new file mode 100644
index 0000000..51f4954
--- /dev/null
+++ b/samples/adsafe.js
@@ -0,0 +1,2060 @@
+// adsafe.js
+// 2017-06-12
+
+//    Public Domain.
+
+//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
+//    SUBJECT TO CHANGE WITHOUT NOTICE.
+
+//    Original url: http://www.ADsafe.org/adsafe.js
+
+// This file implements the core ADSAFE runtime. A site may add additional
+// methods understanding that those methods will be made available to guest
+// code.
+
+// This code should be minified before deployment.
+// See http://javascript.crockford.com/jsmin.html
+
+// USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
+// NOT CONTROL.
+
+/*global window*/
+
+/*jslint browser, devel, for, this
+*/
+
+/*property
+    _, ___nodes___, ___star___, _intercept, a, abbr, acronym, addEventListener,
+    address, altKey, append, appendChild, apply, area, arguments, autocomplete,
+    b, bdo, big, blockquote, blur, br, bubble, button, call, callee, caller,
+    cancelBubble, canvas, caption, center, change, charAt, charCode, check,
+    checked, childNodes, cite, class, className, clientX, clientY, clone,
+    cloneNode, code, col, colgroup, combine, concat, console, constructor,
+    count, create, createDocumentFragment, createElement, createRange,
+    createTextNode, createTextRange, cssFloat, ctrlKey, currentStyle, dd,
+    defaultView, del, dfn, dir, disabled, div, dl, dt, each, em, empty, enable,
+    ephemeral, eval, exec, expand, explode, fieldset, fire, firstChild, focus,
+    font, form, fragment, fromCharCode, get, getCheck, getChecks, getClass,
+    getClasses, getComputedStyle, getElementById, getElementsByTagName,
+    getMark, getMarks, getName, getNames, getOffsetHeight, getOffsetHeights,
+    getOffsetWidth, getOffsetWidths, getParent, getSelection, getStyle,
+    getStyles, getTagName, getTagNames, getTitle, getTitles, getValue,
+    getValues, go, h1, h2, h3, h4, h5, h6, has, hasOwnProperty, hr, i, id, img,
+    inRange, indeterminate, indexOf, input, ins, insertBefore, isArray, kbd,
+    key, keyCode, keys, klass, label, later, legend, length, li, lib, log, map,
+    mark, menu, message, name, nextSibling, nodeName, nodeValue, object, off,
+    offsetHeight, offsetWidth, ol, on, onclick, ondblclick, onfocusin,
+    onfocusout, onkeypress, onmousedown, onmousemove, onmouseout, onmouseover,
+    onmouseup, op, optgroup, option, p, parent, parentNode, postError, pre,
+    prepend, preventDefault, protect, prototype, push, q, remove, removeChild,
+    removeElement, replace, replaceChild, returnValue, row, samp, select,
+    selection, selectionEnd, selectionStart, set, shiftKey, slice, small, span,
+    srcElement, stack, stopPropagation, strong, style, styleFloat, sub, sup,
+    table, tag, tagName, target, tbody, td, test, text, textarea, tfoot, th,
+    that, thead, title, toLowerCase, toString, toUpperCase, tr, tt, type, u,
+    ul, unwatch, value, valueOf, var, visibility, watch, window, writeln, x, y
+*/
+
+var ADSAFE;
+ADSAFE = (function () {
+    "use strict";
+
+    var adsafe_id;      // The id of the current widget
+    var adsafe_lib;     // The script libraries loaded by the current widget
+
+// These member names are banned from guest scripts. The ADSAFE.get and
+// ADSAFE.put methods will not allow access to these properties.
+
+    var banned = {
+        arguments: true,
+        callee: true,
+        caller: true,
+        constructor: true,
+        eval: true,
+        prototype: true,
+        stack: true,
+        unwatch: true,
+        valueOf: true,
+        watch: true
+    };
+
+    var cache_style_object;
+    var cache_style_node;
+    var defaultView = document.defaultView;
+    var ephemeral;
+    var flipflop;       // Used in :even/:odd processing
+    var has_focus;
+    var hunter;         // Set of hunter patterns
+    var interceptors = [];
+
+    var makeableTagName = {
+
+// This is the whitelist of elements that may be created with the .tag(tagName)
+// method.
+
+        a: true,
+        abbr: true,
+        acronym: true,
+        address: true,
+        area: true,
+        b: true,
+        bdo: true,
+        big: true,
+        blockquote: true,
+        br: true,
+        button: true,
+        canvas: true,
+        caption: true,
+        center: true,
+        cite: true,
+        code: true,
+        col: true,
+        colgroup: true,
+        dd: true,
+        del: true,
+        dfn: true,
+        dir: true,
+        div: true,
+        dl: true,
+        dt: true,
+        em: true,
+        fieldset: true,
+        font: true,
+        form: true,
+        h1: true,
+        h2: true,
+        h3: true,
+        h4: true,
+        h5: true,
+        h6: true,
+        hr: true,
+        i: true,
+        img: true,
+        input: true,
+        ins: true,
+        kbd: true,
+        label: true,
+        legend: true,
+        li: true,
+        map: true,
+        menu: true,
+        object: true,
+        ol: true,
+        optgroup: true,
+        option: true,
+        p: true,
+        pre: true,
+        q: true,
+        samp: true,
+        select: true,
+        small: true,
+        span: true,
+        strong: true,
+        sub: true,
+        sup: true,
+        table: true,
+        tbody: true,
+        td: true,
+        textarea: true,
+        tfoot: true,
+        th: true,
+        thead: true,
+        tr: true,
+        tt: true,
+        u: true,
+        ul: true,
+        var: true
+    };
+    var name;
+    var pecker;     // set of pecker patterns
+    var result;
+    var star;
+    var the_range;
+    var value;
+
+
+//  The error function is called if there is a violation or confusion.
+//  It throws an exception.
+
+    function error(message) {
+        ADSAFE.log("ADsafe error: " + (message || "ADsafe violation."));
+        throw {
+            name: "ADsafe",
+            message: message || "ADsafe violation."
+        };
+    }
+
+
+//    Some of JavaScript's implicit string conversions can grant extraordinary
+//    powers to untrusted code. So we use the string_check function to prevent
+//    such abuses.
+
+    function string_check(string) {
+        if (typeof string !== "string") {
+            error("ADsafe string violation.");
+        }
+        return string;
+    }
+
+
+//    The object.hasOwnProperty method has a number of hazards. So we wrap it in
+//    the owns function.
+
+    function owns(object, string) {
+        return (
+            object
+            && typeof object === "object"
+            && Object.prototype.hasOwnProperty.call(object, string_check(string))
+        );
+    }
+
+//  The reject functions enforce the restriction on property names.
+//  reject_property allows access only to objects and arrays. It does not allow
+//  use of the banned names, or names that are not strings and not numbers,
+//  or strings that start or end with _.
+
+    function reject_name(name) {
+        return (
+            typeof name !== "number"
+            && (
+                typeof name !== "string"
+                || banned[name]
+                || name.charAt(0) === "_"
+                || name.slice(-1) === "_"
+            )
+        );
+    }
+
+
+    function reject_property(object, name) {
+        return typeof object !== "object" || reject_name(name);
+    }
+
+
+    function reject_global(that) {
+        if (that.window) {
+            error();
+        }
+    }
+
+
+    function getStyleObject(node) {
+
+// The getStyleObject function returns the computed style object for a node.
+
+        if (node === cache_style_node) {
+            return cache_style_object;
+        }
+        cache_style_node = node;
+        cache_style_object = (
+            node.currentStyle
+            || defaultView.getComputedStyle(node, "")
+        );
+        return cache_style_object;
+    }
+
+
+    function walkTheDOM(node, func, skip) {
+
+// Recursively traverse the DOM tree, starting with the node, in document
+// source order, calling the func on each node visisted.
+
+        if (!skip) {
+            func(node);
+        }
+        node = node.firstChild;
+        while (node) {
+            walkTheDOM(node, func);
+            node = node.nextSibling;
+        }
+    }
+
+
+    function purge_event_handlers(node) {
+
+// We attach all event handlers to an "___ on ___" property. The property name
+// contains spaces to insure that there is no collision with HTML attribues.
+// Keeping the handlers in a single property makes it easy to remove them
+// all at once. Removal is required to avoid memory leakage on IE6 and IE7.
+
+        walkTheDOM(node, function (node) {
+            if (node.tagName) {
+                node["___ on ___"] = null;
+                node.change = null;
+            }
+        });
+    }
+
+
+    function parse_query(text, id) {
+
+// Convert a query string into an array of op/name/value selectors.
+// A query string is a sequence of triples wrapped in brackets; or names,
+// possibly prefixed by # . & > _, or :option, or * or /. A triple is a name,
+// and operator (one of [=, [!=, [*=, [~=, [|=, [$=, or [^=) and a value.
+
+// If the id parameter is supplied, then the name following # must have the
+// id as a prefix and must match the ADsafe rule for id: being all uppercase
+// letters and digits with one underbar.
+
+// A name must be all lower case and may contain digits, -, or _.
+
+        var match;          // A match array
+        var query = [];     // The resulting query array
+        var selector;
+        var qx = (id)
+            ? /^\s*(?:([*\/])|\[\s*([a-z][0-9a-z_\-]*)\s*(?:([!*~|$\^]?=)\s*([0-9A-Za-z_\-*%&;.\/:!]+)\s*)?\]|#\s*([A-Z]+_[A-Z0-9]+)|:\s*([a-z]+)|([.&_>+]?)\s*([a-z][0-9a-z\-]*))\s*/
+            : /^\s*(?:([*\/])|\[\s*([a-z][0-9a-z_\-]*)\s*(?:([!*~|$\^]?=)\s*([0-9A-Za-z_\-*%&;.\/:!]+)\s*)?\]|#\s*([\-A-Za-z0-9_]+)|:\s*([a-z]+)|([.&_>+]?)\s*([a-z][0-9a-z\-]*))\s*/;
+
+// Loop over all of the selectors in the text.
+
+        do {
+
+// The qx teases the components of one selector out of the text, ignoring
+// whitespace.
+
+//          match[0]  the whole selector
+//          match[1]  * /
+//          match[2]  attribute name
+//          match[3]  = != *= ~= |= $= ^=
+//          match[4]  attribute value
+//          match[5]  # id
+//          match[6]  : option
+//          match[7]  . & _ > +
+//          match[8]      name
+
+            match = qx.exec(string_check(text));
+            if (!match) {
+                error("ADsafe: Bad query:" + text);
+            }
+
+// Make a selector object and stuff it in the query.
+
+            if (match[1]) {
+
+// The selector is * or /
+
+                selector = {
+                    op: match[1]
+                };
+            } else if (match[2]) {
+
+// The selector is in brackets.
+
+                selector = (match[3])
+                    ? {
+                        op: "[" + match[3],
+                        name: match[2],
+                        value: match[4]
+                    }
+                    : {
+                        op: "[",
+                        name: match[2]
+                    };
+            } else if (match[5]) {
+
+// The selector is an id.
+
+                if (
+                    query.length > 0
+                    || match[5].length <= id.length
+                    || match[5].slice(0, id.length) !== id
+                ) {
+                    error("ADsafe: Bad query: " + text);
+                }
+                selector = {
+                    op: "#",
+                    name: match[5]
+                };
+
+// The selector is a colon.
+
+            } else if (match[6]) {
+                selector = {
+                    op: ":" + match[6]
+                };
+
+// The selector is one of > + . & _ or a naked tag name
+
+            } else {
+                selector = {
+                    op: match[7],
+                    name: match[8]
+                };
+            }
+
+// Add the selector to the query.
+
+            query.push(selector);
+
+// Remove the selector from the text. If there is more text, have another go.
+
+            text = text.slice(match[0].length);
+        } while (text);
+        return query;
+    }
+
+
+    hunter = {
+
+// These functions implement the hunter behaviors.
+
+        "": function (node) {
+            var array;
+            var nodelist = node.getElementsByTagName(name);
+            var i;
+            var length;
+
+// getElementsByTagName produces a nodeList, which is one of the world's most
+// inefficient data structures. It is so slow that JavaScript's pseudo arrays
+// look terrifically swift by comparison. So we do the conversion. This is
+// easily done on some browsers, less easily on others.
+
+            try {
+                array = Array.prototype.slice.call(nodelist, 0);
+                result = (result.length)
+                    ? result.concat(array)
+                    : array;
+            } catch (ignore) {
+                length = nodelist.length;
+                for (i = 0; i < length; i += 1) {
+                    result.push(nodelist[i]);
+                }
+            }
+        },
+        "+": function (node) {
+            node = node.nextSibling;
+            name = name.toUpperCase();
+            while (node && !node.tagName) {
+                node = node.nextSibling;
+            }
+            if (node && node.tagName === name) {
+                result.push(node);
+            }
+        },
+        ">": function (node) {
+            node = node.firstChild;
+            name = name.toUpperCase();
+            while (node) {
+                if (node.tagName === name) {
+                    result.push(node);
+                }
+                node = node.nextSibling;
+            }
+        },
+        "#": function () {
+            var n = document.getElementById(name);
+            if (n.tagName) {
+                result.push(n);
+            }
+        },
+        "/": function (node) {
+            var nodes = node.childNodes;
+            var i;
+            var length = nodes.length;
+            for (i = 0; i < length; i += 1) {
+                result.push(nodes[i]);
+            }
+        },
+        "*": function (node) {
+            star = true;
+            walkTheDOM(node, function (node) {
+                result.push(node);
+            }, true);
+        }
+    };
+
+    pecker = {
+        ".": function (node) {
+            var classy = " " + node.className + " ";
+            return classy.indexOf(" " + name + " ") >= 0;
+        },
+        "&": function (node) {
+            return node.name === name;
+        },
+        "_": function (node) {
+            return node.type === name;
+        },
+        "[": function (node) {
+            return typeof node[name] === "string";
+        },
+        "[=": function (node) {
+            var member = node[name];
+            return typeof member === "string" && member === value;
+        },
+        "[!=": function (node) {
+            var member = node[name];
+            return typeof member === "string" && member !== value;
+        },
+        "[^=": function (node) {
+            var member = node[name];
+            return typeof member === "string" &&
+                    member.slice(0, member.length) === value;
+        },
+        "[$=": function (node) {
+            var member = node[name];
+            return typeof member === "string" &&
+                    member.slice(-member.length) === value;
+        },
+        "[*=": function (node) {
+            var member = node[name];
+            return typeof member === "string" &&
+                    member.indexOf(value) >= 0;
+        },
+        "[~=": function (node) {
+            var member = node[name];
+            if (typeof member === "string") {
+                member = " " + member + " ";
+                return member.indexOf(" " + value + " ") >= 0;
+            }
+        },
+        "[|=": function (node) {
+            var member = node[name];
+            if (typeof member === "string") {
+                member = "-" + member + "-";
+                return member.indexOf("-" + value + "-") >= 0;
+            }
+        },
+        ":blur": function (node) {
+            return node !== has_focus;
+        },
+        ":checked": function (node) {
+            return node.checked;
+        },
+        ":disabled": function (node) {
+            return node.tagName && node.disabled;
+        },
+        ":enabled": function (node) {
+            return node.tagName && !node.disabled;
+        },
+        ":even": function (node) {
+            var f;
+            if (node.tagName) {
+                f = flipflop;
+                flipflop = !flipflop;
+                return f;
+            }
+            return false;
+        },
+        ":focus": function (node) {
+            return node === has_focus;
+        },
+        ":hidden": function (node) {
+            return node.tagName && getStyleObject(node).visibility !== "visible";
+        },
+        ":odd": function (node) {
+            if (node.tagName) {
+                flipflop = !flipflop;
+                return flipflop;
+            }
+            return false;
+        },
+        ":tag": function (node) {
+            return node.tagName;
+        },
+        ":text": function (node) {
+            return node.nodeName === "#text";
+        },
+        ":trim": function (node) {
+            return node.nodeName !== "#text" || (/\W/.test(node.nodeValue));
+        },
+        ":unchecked": function (node) {
+            return node.tagName && !node.checked;
+        },
+        ":visible": function (node) {
+            return node.tagName && getStyleObject(node).visibility === "visible";
+        }
+    };
+
+
+    function quest(query, nodes) {
+        var selector;
+        var func;
+        var i;
+        var j;
+
+// Step through each selector.
+
+        for (i = 0; i < query.length; i += 1) {
+            selector = query[i];
+            name = selector.name;
+            func = hunter[selector.op];
+
+// There are two kinds of selectors: hunters and peckers. If this is a hunter,
+// loop through the the nodes, passing each node to the hunter function.
+// Accumulate all the nodes it finds.
+
+            if (typeof func === "function") {
+                if (star) {
+                    error(
+                        "ADsafe: Query violation: *"
+                        + selector.op
+                        + (selector.name || "")
+                    );
+                }
+                result = [];
+                for (j = 0; j < nodes.length; j += 1) {
+                    func(nodes[j]);
+                }
+            } else {
+
+// If this is a pecker, get its function. There is a special case for
+// the :first and :rest selectors because they are so simple.
+
+                value = selector.value;
+                flipflop = false;
+                func = pecker[selector.op];
+                if (typeof func !== "function") {
+                    switch (selector.op) {
+                    case ":first":
+                        result = nodes.slice(0, 1);
+                        break;
+                    case ":rest":
+                        result = nodes.slice(1);
+                        break;
+                    default:
+                        error("ADsafe: Query violation: :" + selector.op);
+                    }
+                } else {
+
+// For the other selectors, make an array of nodes that are filtered by
+// the pecker function.
+
+                    result = [];
+                    for (j = 0; j < nodes.length; j += 1) {
+                        if (func(nodes[j])) {
+                            result.push(nodes[j]);
+                        }
+                    }
+                }
+            }
+            nodes = result;
+        }
+        return result;
+    }
+
+
+    function make_root(root, id) {
+
+        if (id) {
+            if (root.tagName !== "DIV") {
+                error("ADsafe: Bad node.");
+            }
+        } else {
+            if (root.tagName !== "BODY") {
+                error("ADsafe: Bad node.");
+            }
+        }
+
+// A Bunch is a container that holds zero or more dom nodes.
+// It has many useful methods.
+
+        function Bunch(nodes) {
+            this.___nodes___ = nodes;
+            this.___star___ = star && nodes.length > 1;
+            star = false;
+        }
+
+        var allow_focus = true;
+        var dom;
+        var dom_event = function (ev) {
+            var key;
+            var target;
+            var that;
+            var the_event;
+            var the_target;
+            var the_actual_event = ev || event;
+            var type = the_actual_event.type;
+
+// Get the target node and wrap it in a bunch.
+
+            the_target = the_actual_event.target || the_actual_event.srcElement;
+            target = new Bunch([the_target]);
+            that = target;
+
+// Use the PPK hack to make focus bubbly on IE.
+// When a widget has focus, it can use the focus method.
+
+            switch (type) {
+            case "mousedown":
+                allow_focus = true;
+                if (document.selection) {
+                    the_range = document.selection.createRange();
+                }
+                break;
+            case "focus":
+            case "focusin":
+                allow_focus = true;
+                has_focus = the_target;
+                the_actual_event.cancelBubble = false;
+                type = "focus";
+                break;
+            case "blur":
+            case "focusout":
+                allow_focus = false;
+                has_focus = null;
+                type = "blur";
+                break;
+            case "keypress":
+                allow_focus = true;
+                has_focus = the_target;
+                key = String.fromCharCode(
+                    the_actual_event.charCode || the_actual_event.keyCode
+                );
+                switch (key) {
+                case "\u000d":
+                case "\u000a":
+                    type = "enterkey";
+                    break;
+                case "\u001b":
+                    type = "escapekey";
+                    break;
+                }
+                break;
+
+// This is a workaround for Safari.
+
+            case "click":
+                allow_focus = true;
+                break;
+            }
+            if (
+                the_actual_event.cancelBubble
+                && the_actual_event.stopPropagation
+            ) {
+                the_actual_event.stopPropagation();
+            }
+
+// Make the event object.
+
+            the_event = {
+                altKey: the_actual_event.altKey,
+                ctrlKey: the_actual_event.ctrlKey,
+                bubble: function () {
+
+// Bubble up. Get the parent of that node. It becomes the new that.
+// getParent throws when bubbling is not possible.
+
+                    try {
+                        var parent = that.getParent();
+                        var b = parent.___nodes___[0];
+                        that = parent;
+                        the_event.that = that;
+
+// If that node has an event handler, fire it. Otherwise, bubble up.
+
+                        if (
+                            b["___ on ___"] && b["___ on ___"][type]
+                        ) {
+                            that.fire(the_event);
+                        } else {
+                            the_event.bubble();
+                        }
+                    } catch (e) {
+                        error(e);
+                    }
+                },
+                key: key,
+                preventDefault: function () {
+                    if (the_actual_event.preventDefault) {
+                        the_actual_event.preventDefault();
+                    }
+                    the_actual_event.returnValue = false;
+                },
+                shiftKey: the_actual_event.shiftKey,
+                target: target,
+                that: that,
+                type: type,
+                x: the_actual_event.clientX,
+                y: the_actual_event.clientY
+            };
+
+// If the target has event handlers, then fire them. Otherwise, bubble up.
+
+            if (
+                the_target["___ on ___"]
+                && the_target["___ on ___"][the_event.type]
+            ) {
+                target.fire(the_event);
+            } else {
+                while (true) {
+                    the_target = the_target.parentNode;
+                    if (!the_target) {
+                        break;
+                    }
+                    if (
+                        the_target["___ on ___"]
+                        && the_target["___ on ___"][the_event.type]
+                    ) {
+                        that = new Bunch([the_target]);
+                        the_event.that = that;
+                        that.fire(the_event);
+                        break;
+                    }
+                    if (the_target["___adsafe root___"]) {
+                        break;
+                    }
+                }
+            }
+            if (the_event.type === "escapekey") {
+                if (ephemeral) {
+                    ephemeral.remove();
+                }
+                ephemeral = null;
+            }
+            that = null;
+            the_actual_event = null;
+            the_event = null;
+            the_target = null;
+            return;
+        };
+
+// Mark the node as a root. This prevents event bubbling from propagating
+// past it.
+
+        root["___adsafe root___"] = "___adsafe root___";
+
+        Bunch.prototype = {
+            append: function (appendage) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var flag = false;
+                var i;
+                var j;
+                var node;
+                var rep;
+                if (b.length === 0 || !appendage) {
+                    return this;
+                }
+                if (Array.isArray(appendage)) {
+                    if (appendage.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        rep = appendage[i].___nodes___;
+                        for (j = 0; j < rep.length; j += 1) {
+                            b[i].appendChild(rep[j]);
+                        }
+                    }
+                } else {
+                    if (typeof appendage !== "string") {
+                        rep = appendage.___nodes___;
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (rep) {
+                            for (j = 0; j < rep.length; j += 1) {
+                                node.appendChild((flag)
+                                    ? rep[j].cloneNode(true)
+                                    : rep[j]);
+                            }
+                            flag = true;
+                        } else {
+                            node.appendChild(document.createTextNode(appendage));
+                        }
+                    }
+                }
+                return this;
+            },
+            blur: function () {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                has_focus = null;
+                for (i = 0; i < b.length; i += 1) {
+                    node = b[i];
+                    if (node.blur) {
+                        node.blur();
+                    }
+                }
+                return this;
+            },
+            check: function (value) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                if (Array.isArray(value)) {
+                    if (value.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.checked = !!value[i];
+                        }
+                    }
+                } else {
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.checked = !!value;
+                        }
+                    }
+                }
+                return this;
+            },
+            "class": function (value) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                if (Array.isArray(value)) {
+                    if (value.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        if (/url/i.test(string_check(value[i]))) {
+                            error("ADsafe error.");
+                        }
+                        node = b[i];
+                        if (node.tagName) {
+                            node.className = value[i];
+                        }
+                    }
+                } else {
+                    if (/url/i.test(string_check(value))) {
+                        error("ADsafe error.");
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.className = value;
+                        }
+                    }
+                }
+                return this;
+            },
+            clone: function (deep, n) {
+                var a = [];
+                var b = this.___nodes___;
+                var c;
+                var i;
+                var j;
+                var k = n || 1;
+                for (i = 0; i < k; i += 1) {
+                    c = [];
+                    for (j = 0; j < b.length; j += 1) {
+                        c.push(b[j].cloneNode(deep));
+                    }
+                    a.push(new Bunch(c));
+                }
+                return (n)
+                    ? a
+                    : a[0];
+            },
+            count: function () {
+                reject_global(this);
+                return this.___nodes___.length;
+            },
+            each: function (func) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                if (typeof func === "function") {
+                    for (i = 0; i < b.length; i += 1) {
+                        func(new Bunch([b[i]]));
+                    }
+                    return this;
+                }
+                error();
+            },
+            empty: function () {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                if (Array.isArray(value)) {
+                    if (value.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length
+                            + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        while (node.firstChild) {
+                            purge_event_handlers(node);
+                            node.removeChild(node.firstChild);
+                        }
+                    }
+                } else {
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        while (node.firstChild) {
+                            purge_event_handlers(node);
+                            node.removeChild(node.firstChild);
+                        }
+                    }
+                }
+                return this;
+            },
+            enable: function (enable) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                if (Array.isArray(enable)) {
+                    if (enable.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length + "-"
+                            + enable.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.disabled = !enable[i];
+                        }
+                    }
+                } else {
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.disabled = !enable;
+                        }
+                    }
+                }
+                return this;
+            },
+            ephemeral: function () {
+                reject_global(this);
+                if (ephemeral) {
+                    ephemeral.remove();
+                }
+                ephemeral = this;
+                return this;
+            },
+            explode: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    a[i] = new Bunch([b[i]]);
+                }
+                return a;
+            },
+            fire: function (event) {
+
+    // Fire an event on an object. The event can be either
+    // a string containing the name of the event, or an
+    // object containing a type property containing the
+    // name of the event. Handlers registered by the "on"
+    // method that match the event name will be invoked.
+
+                reject_global(this);
+                var array;
+                var b;
+                var i;
+                var j;
+                var n;
+                var node;
+                var on;
+                var type;
+
+                if (typeof event === "string") {
+                    type = event;
+                    event = {type: type};
+                } else if (typeof event === "object") {
+                    type = event.type;
+                } else {
+                    error();
+                }
+                b = this.___nodes___;
+                n = b.length;
+                for (i = 0; i < n; i += 1) {
+                    node = b[i];
+                    on = node["___ on ___"];
+
+    // If an array of handlers exist for this event, then
+    // loop through it and execute the handlers in order.
+
+                    if (owns(on, type)) {
+                        array = on[type];
+                        for (j = 0; j < array.length; j += 1) {
+
+    // Invoke a handler. Pass the event object.
+
+                            array[j].call(this, event);
+                        }
+                    }
+                }
+                return this;
+            },
+            focus: function () {
+                reject_global(this);
+                var b = this.___nodes___;
+                if (b.length > 0 && allow_focus) {
+                    has_focus = b[0].focus();
+                    return this;
+                }
+                error();
+            },
+            fragment: function () {
+                reject_global(this);
+                return new Bunch([document.createDocumentFragment()]);
+            },
+            getCheck: function () {
+                return this.getChecks()[0];
+            },
+            getChecks: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    a[i] = b[i].checked;
+                }
+                return a;
+            },
+            getClass: function () {
+                return this.getClasses()[0];
+            },
+            getClasses: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    a[i] = b[i].className;
+                }
+                return a;
+            },
+            getMark: function () {
+                return this.getMarks()[0];
+            },
+            getMarks: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    a[i] = b[i]["_adsafe mark_"];
+                }
+                return a;
+            },
+            getName: function () {
+                return this.getNames()[0];
+            },
+            getNames: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    a[i] = b[i].name;
+                }
+                return a;
+            },
+            getOffsetHeight: function () {
+                return this.getOffsetHeights()[0];
+            },
+            getOffsetHeights: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    a[i] = b[i].offsetHeight;
+                }
+                return a;
+            },
+            getOffsetWidth: function () {
+                return this.getOffsetWidths()[0];
+            },
+            getOffsetWidths: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    a[i] = b[i].offsetWidth;
+                }
+                return a;
+            },
+            getParent: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                var n;
+                for (i = 0; i < b.length; i += 1) {
+                    n = b[i].parentNode;
+                    if (n["___adsafe root___"]) {
+                        error("ADsafe parent violation.");
+                    }
+                    a[i] = n;
+                }
+                return new Bunch(a);
+            },
+            getSelection: function () {
+                reject_global(this);
+                var b = this.___nodes___;
+                var end;
+                var node;
+                var start;
+                var range;
+                if (b.length === 1 && allow_focus) {
+                    node = b[0];
+                    if (typeof node.selectionStart === "number") {
+                        start = node.selectionStart;
+                        end = node.selectionEnd;
+                        return node.value.slice(start, end);
+                    }
+                    range = node.createTextRange();
+                    range.expand("textedit");
+                    if (range.inRange(the_range)) {
+                        return the_range.text;
+                    }
+                }
+                return null;
+            },
+            getStyle: function (name) {
+                return this.getStyles(name)[0];
+            },
+            getStyles: function (name) {
+                reject_global(this);
+                if (reject_name(name)) {
+                    error("ADsafe style violation.");
+                }
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                var node;
+                var s;
+                for (i = 0; i < b.length; i += 1) {
+                    node = b[i];
+                    if (node.tagName) {
+                        s = (name !== "float")
+                            ? getStyleObject(node)[name]
+                            : getStyleObject(node).cssFloat
+                                    || getStyleObject(node).styleFloat;
+                        if (typeof s === "string") {
+                            a[i] = s;
+                        }
+                    }
+                }
+                return a;
+            },
+            getTagName: function () {
+                return this.getTagNames()[0];
+            },
+            getTagNames: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                var tagName;
+                for (i = 0; i < b.length; i += 1) {
+                    tagName = b[i].tagName;
+                    a[i] = (typeof tagName === "string")
+                        ? tagName.toLowerCase()
+                        : tagName;
+                }
+                return a;
+            },
+            getTitle: function () {
+                return this.getTitles()[0];
+            },
+            getTitles: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    a[i] = b[i].title;
+                }
+                return a;
+            },
+            getValue: function () {
+                return this.getValues()[0];
+            },
+            getValues: function () {
+                reject_global(this);
+                var a = [];
+                var b = this.___nodes___;
+                var i;
+                var node;
+                for (i = 0; i < b.length; i += 1) {
+                    node = b[i];
+                    if (node.nodeName === "#text") {
+                        a[i] = node.nodeValue;
+                    } else if (node.tagName && node.type !== "password") {
+                        a[i] = node.value;
+                        if (
+                            !a[i]
+                            && node.firstChild
+                            && node.firstChild.nodeName === "#text"
+                        ) {
+                            a[i] = node.firstChild.nodeValue;
+                        }
+                    }
+                }
+                return a;
+            },
+            indeterminate: function (value) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                if (Array.isArray(value)) {
+                    if (value.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length
+                            + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.indeterminate = !!value[i];
+                        }
+                    }
+                } else {
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.indeterminate = !!value;
+                        }
+                    }
+                }
+                return this;
+            },
+            klass: function (value) {
+                return this.class(value);
+            },
+            mark: function (value) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                if (Array.isArray(value)) {
+                    if (value.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length
+                            + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node["_adsafe mark_"] = String(value[i]);
+                        }
+                    }
+                } else {
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node["_adsafe mark_"] = String(value);
+                        }
+                    }
+                }
+                return this;
+            },
+            off: function (type) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                for (i = 0; i < b.length; i += 1) {
+                    node = b[i];
+                    if (typeof type === "string") {
+                        if (typeof node["___ on ___"] === "object") {
+                            node["___ on ___"][type] = null;
+                        }
+                    } else {
+                        node["___ on ___"] = null;
+                    }
+                }
+                return this;
+            },
+            on: function (type, func) {
+                reject_global(this);
+                if (typeof type !== "string" || typeof func !== "function") {
+                    error();
+                }
+
+                var b = this.___nodes___;
+                var i;
+                var node;
+                var on;
+                var ontype;
+                for (i = 0; i < b.length; i += 1) {
+                    node = b[i];
+
+// The change event does not propogate, so we must put the handler on the
+// instance.
+
+                    if (type === "change") {
+                        ontype = "on" + type;
+                        if (node[ontype] !== dom_event) {
+                            node[ontype] = dom_event;
+                        }
+                    }
+
+// Register an event. Put the function in a handler array, making one if it
+// doesn't yet exist for this type on this node.
+
+                    on = node["___ on ___"];
+                    if (!on) {
+                        on = {};
+                        node["___ on ___"] = on;
+                    }
+                    if (owns(on, type)) {
+                        on[type].push(func);
+                    } else {
+                        on[type] = [func];
+                    }
+                }
+                return this;
+            },
+            protect: function () {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    b[i]["___adsafe root___"] = "___adsafe root___";
+                }
+                return this;
+            },
+            q: function (text) {
+                reject_global(this);
+                star = this.___star___;
+                return new Bunch(
+                    quest(parse_query(string_check(text), id), this.___nodes___)
+                );
+            },
+            remove: function () {
+                reject_global(this);
+                this.replace();
+            },
+            replace: function (replacement) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var flag = false;
+                var i;
+                var j;
+                var newnode;
+                var node;
+                var parent;
+                var rep;
+                if (b.length === 0) {
+                    return;
+                }
+                for (i = 0; i < b.length; i += 1) {
+                    purge_event_handlers(b[i]);
+                }
+                if (
+                    !replacement || replacement.length === 0
+                    || (
+                        replacement.___nodes___
+                        && replacement.___nodes___.length === 0
+                    )
+                ) {
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        purge_event_handlers(node);
+                        if (node.parentNode) {
+                            node.parentNode.removeChild(node);
+                        }
+                    }
+                } else if (Array.isArray(replacement)) {
+                    if (replacement.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length
+                            + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        parent = node.parentNode;
+                        purge_event_handlers(node);
+                        if (parent) {
+                            rep = replacement[i].___nodes___;
+                            if (rep.length > 0) {
+                                newnode = rep[0];
+                                parent.replaceChild(newnode, node);
+                                for (j = 1; j < rep.length; j += 1) {
+                                    node = newnode;
+                                    newnode = rep[j];
+                                    parent.insertBefore(newnode, node.nextSibling);
+                                }
+                            } else {
+                                parent.removeChild(node);
+                            }
+                        }
+                    }
+                } else {
+                    rep = replacement.___nodes___;
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        purge_event_handlers(node);
+                        parent = node.parentNode;
+                        if (parent) {
+                            newnode = (flag)
+                                ? rep[0].cloneNode(true)
+                                : rep[0];
+                            parent.replaceChild(newnode, node);
+                            for (j = 1; j < rep.length; j += 1) {
+                                node = newnode;
+                                newnode = (flag)
+                                    ? rep[j].clone(true)
+                                    : rep[j];
+                                parent.insertBefore(newnode, node.nextSibling);
+                            }
+                            flag = true;
+                        }
+                    }
+                }
+                return this;
+            },
+            select: function () {
+                reject_global(this);
+                var b = this.___nodes___;
+                if (b.length < 1 || !allow_focus) {
+                    error();
+                }
+                b[0].focus();
+                b[0].select();
+                return this;
+            },
+            selection: function (string) {
+                reject_global(this);
+                string_check(string);
+                var b = this.___nodes___;
+                var end;
+                var node;
+                var old;
+                var start;
+                var range;
+                if (b.length === 1 && allow_focus) {
+                    node = b[0];
+                    if (typeof node.selectionStart === "number") {
+                        start = node.selectionStart;
+                        end = node.selectionEnd;
+                        old = node.value;
+                        node.value = old.slice(0, start) + string + old.slice(end);
+                        node.selectionStart = start + string.length;
+                        node.selectionEnd = start + string.length;
+                        node.focus();
+                    } else {
+                        range = node.createTextRange();
+                        range.expand("textedit");
+                        if (range.inRange(the_range)) {
+                            the_range.select();
+                            the_range.text = string;
+                            the_range.select();
+                        }
+                    }
+                }
+                return this;
+            },
+            style: function (name, value) {
+                reject_global(this);
+                if (reject_name(name)) {
+                    error("ADsafe style violation.");
+                }
+                if (value === undefined || (/url/i.test(string_check(value)))) {
+                    error();
+                }
+                var b = this.___nodes___;
+                var i;
+                var node;
+                var v;
+                if (Array.isArray(value)) {
+                    if (value.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length
+                            + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        v = string_check(value[i]);
+                        if (/url/i.test(v)) {
+                            error();
+                        }
+                        if (node.tagName) {
+                            if (name !== "float") {
+                                node.style[name] = v;
+                            } else {
+                                node.style.cssFloat = v;
+                                node.style.styleFloat = v;
+                            }
+                        }
+                    }
+                } else {
+                    v = string_check(value);
+                    if (/url/i.test(v)) {
+                        error();
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            if (name !== "float") {
+                                node.style[name] = v;
+                            } else {
+                                node.style.cssFloat = v;
+                                node.style.styleFloat = v;
+                            }
+                        }
+                    }
+                }
+                return this;
+            },
+            tag: function (tag, type, name) {
+                reject_global(this);
+                var node;
+                if (typeof tag !== "string") {
+                    error();
+                }
+                if (makeableTagName[tag] !== true) {
+                    error("ADsafe: Bad tag: " + tag);
+                }
+                node = document.createElement(tag);
+                if (name) {
+                    node.autocomplete = "off";
+                    node.name = string_check(name);
+                }
+                if (type) {
+                    node.type = string_check(type);
+                }
+                return new Bunch([node]);
+            },
+            text: function (text) {
+                reject_global(this);
+                var a;
+                var i;
+                if (Array.isArray(text)) {
+                    a = [];
+                    for (i = 0; i < text.length; i += 1) {
+                        a[i] = document.createTextNode(string_check(text[i]));
+                    }
+                    return new Bunch(a);
+                }
+                return new Bunch([document.createTextNode(string_check(text))]);
+            },
+            title: function (value) {
+                reject_global(this);
+                var b = this.___nodes___;
+                var i;
+                var node;
+                if (Array.isArray(value)) {
+                    if (value.length !== b.length) {
+                        error(
+                            "ADsafe: Array length: "
+                            + b.length
+                            + "-"
+                            + value.length
+                        );
+                    }
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.title = string_check(value[i]);
+                        }
+                    }
+                } else {
+                    string_check(value);
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            node.title = value;
+                        }
+                    }
+                }
+                return this;
+            },
+            value: function (value) {
+                reject_global(this);
+                if (value === undefined) {
+                    error();
+                }
+                var b = this.___nodes___;
+                var i;
+                var node;
+                if (Array.isArray(value) && b.length === value.length) {
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            if (node.type !== "password") {
+                                if (typeof node.value === "string") {
+                                    node.value = value[i];
+                                } else {
+                                    while (node.firstChild) {
+                                        purge_event_handlers(node.firstChild);
+                                        node.removeChild(node.firstChild);
+                                    }
+                                    node.appendChild(document.createTextNode(
+                                        String(value[i])
+                                    ));
+                                }
+                            }
+                        } else if (node.nodeName === "#text") {
+                            node.nodeValue = String(value[i]);
+                        }
+                    }
+                } else {
+                    value = String(value);
+                    for (i = 0; i < b.length; i += 1) {
+                        node = b[i];
+                        if (node.tagName) {
+                            if (
+                                node.tagName !== "BUTTON"
+                                && typeof node.value === "string"
+                            ) {
+                                node.value = value;
+                            } else {
+                                while (node.firstChild) {
+                                    purge_event_handlers(node.firstChild);
+                                    node.removeChild(node.firstChild);
+                                }
+                                node.appendChild(document.createTextNode(value));
+                            }
+                        } else if (node.nodeName === "#text") {
+                            node.nodeValue = value;
+                        }
+                    }
+                }
+                return this;
+            }
+        };
+
+// Return an ADsafe dom object.
+
+        dom = {
+            append: function (bunch) {
+                var b = (typeof bunch === "string")
+                    ? [document.createTextNode(bunch)]
+                    : bunch.___nodes___;
+                var i;
+                var n;
+                for (i = 0; i < b.length; i += 1) {
+                    n = b[i];
+                    if (typeof n === "string" || typeof n === "number") {
+                        n = document.createTextNode(String(n));
+                    }
+                    root.appendChild(n);
+                }
+                return dom;
+            },
+            combine: function (array) {
+                if (!array || !array.length) {
+                    error("ADsafe: Bad combination.");
+                }
+                var b = array[0].___nodes___;
+                var i;
+                for (i = 0; i < array.length; i += 1) {
+                    b = b.concat(array[i].___nodes___);
+                }
+                return new Bunch(b);
+            },
+            count: function () {
+                return 1;
+            },
+            ephemeral: function (bunch) {
+                if (ephemeral) {
+                    ephemeral.remove();
+                }
+                ephemeral = bunch;
+                return dom;
+            },
+            fragment: function () {
+                return new Bunch([document.createDocumentFragment()]);
+            },
+            prepend: function (bunch) {
+                var b = bunch.___nodes___;
+                var i;
+                for (i = 0; i < b.length; i += 1) {
+                    root.insertBefore(b[i], root.firstChild);
+                }
+                return dom;
+            },
+            q: function (text) {
+                star = false;
+                var query = parse_query(text, id);
+                if (typeof hunter[query[0].op] !== "function") {
+                    error("ADsafe: Bad query: " + query[0]);
+                }
+                return new Bunch(quest(query, [root]));
+            },
+            remove: function () {
+                purge_event_handlers(root);
+                root.parent.removeElement(root);
+                root = null;
+            },
+            row: function (values) {
+                var tr = document.createElement("tr");
+                var td;
+                var i;
+                for (i = 0; i < values.length; i += 1) {
+                    td = document.createElement("td");
+                    td.appendChild(document.createTextNode(String(values[i])));
+                    tr.appendChild(td);
+                }
+                return new Bunch([tr]);
+            },
+            tag: function (tag, type, name) {
+                var node;
+                if (typeof tag !== "string") {
+                    error();
+                }
+                if (makeableTagName[tag] !== true) {
+                    error("ADsafe: Bad tag: " + tag);
+                }
+                node = document.createElement(tag);
+                if (name) {
+                    node.autocomplete = "off";
+                    node.name = name;
+                }
+                if (type) {
+                    node.type = type;
+                }
+                return new Bunch([node]);
+            },
+            text: function (text) {
+                var a;
+                var i;
+                if (Array.isArray(text)) {
+                    a = [];
+                    for (i = 0; i < text.length; i += 1) {
+                        a[i] = document.createTextNode(string_check(text[i]));
+                    }
+                    return new Bunch(a);
+                }
+                return new Bunch([document.createTextNode(string_check(text))]);
+            }
+        };
+
+        if (typeof root.addEventListener === "function") {
+            root.addEventListener("focus", dom_event, true);
+            root.addEventListener("blur", dom_event, true);
+            root.addEventListener("mouseover", dom_event, true);
+            root.addEventListener("mouseout", dom_event, true);
+            root.addEventListener("mouseup", dom_event, true);
+            root.addEventListener("mousedown", dom_event, true);
+            root.addEventListener("mousemove", dom_event, true);
+            root.addEventListener("click", dom_event, true);
+            root.addEventListener("dblclick", dom_event, true);
+            root.addEventListener("keypress", dom_event, true);
+        } else {
+            root.onclick = dom_event;
+            root.ondblclick = dom_event;
+            root.onfocusin = dom_event;
+            root.onfocusout = dom_event;
+            root.onkeypress = dom_event;
+            root.onmouseout = dom_event;
+            root.onmousedown = dom_event;
+            root.onmousemove = dom_event;
+            root.onmouseover = dom_event;
+            root.onmouseup = dom_event;
+        }
+        return [dom, Bunch.prototype];
+    }
+
+
+//  Return the ADSAFE object.
+
+    return {
+        create: function (o) {
+            reject_global(o);
+            return Object.create(o);
+        },
+
+//  ADSAFE.get retrieves a value from an object.
+
+        get: function (object, name) {
+            reject_global(object);
+            if (!reject_property(object, name)) {
+                return object[name];
+            }
+            error();
+        },
+
+//  ADSAFE.go allows a guest widget to get access to a wrapped dom node and
+//  approved ADsafe libraries. It is passed an id and a function. The function
+//  will be passed the wrapped dom node and an object containing the libraries.
+
+        go: function (id, f) {
+            var dom;
+            var fun;
+            var root;
+            var i;
+            var scripts;
+
+//  If ADSAFE.id was called, the id better match.
+
+            if (adsafe_id && adsafe_id !== id) {
+                error();
+            }
+
+//  Get the dom node for the widget's div container.
+
+            root = document.getElementById(id);
+            if (root.tagName !== "DIV") {
+                error();
+            }
+            adsafe_id = null;
+
+//  Delete the scripts held in the div. They have all run, so we don't need
+//  them any more. If the div had no scripts, then something is wrong.
+//  This provides some protection against mishaps due to weakness in the
+//  document.getElementById function.
+
+            scripts = root.getElementsByTagName("script");
+            i = scripts.length - 1;
+            if (i < 0) {
+                error();
+            }
+            do {
+                root.removeChild(scripts[i]);
+                i -= 1;
+            } while (i >= 0);
+            root = make_root(root, id);
+            dom = root[0];
+
+// If the page has registered interceptors, call then.
+
+            for (i = 0; i < interceptors.length; i += 1) {
+                fun = interceptors[i];
+                if (typeof fun === "function") {
+                    try {
+                        fun(id, dom, adsafe_lib, root[1]);
+                    } catch (e1) {
+                        ADSAFE.log(e1);
+                    }
+                }
+            }
+
+//  Call the supplied function.
+
+            try {
+                f(dom, adsafe_lib);
+            } catch (e2) {
+                ADSAFE.log(e2);
+            }
+            root = null;
+            adsafe_lib = null;
+        },
+
+//  ADSAFE.has returns true if the object contains an own property with the
+//  given name.
+
+        has: function (object, name) {
+            return owns(object, name);
+        },
+
+//  ADSAFE.id allows a guest widget to indicate that it wants to load
+//  ADsafe approved libraries.
+
+        id: function (id) {
+
+//  Calls to ADSAFE.id must be balanced with calls to ADSAFE.go.
+//  Only one id can be active at a time.
+
+            if (adsafe_id) {
+                error();
+            }
+            adsafe_id = id;
+            adsafe_lib = {};
+        },
+
+//  ADSAFE.isArray returns true if the operand is an array.
+
+        isArray: Array.isArray || function (value) {
+            return Object.prototype.toString.apply(value) === "[object Array]";
+        },
+
+//  ADSAFE.keys returns an array of keys.
+
+        keys: Object.keys,
+
+//  ADSAFE.later calls a function at a later time.
+
+        later: function (func, timeout) {
+            if (typeof func === "function") {
+                setTimeout(func, timeout || 0);
+            } else {
+                error();
+            }
+        },
+
+//  ADSAFE.lib allows an approved ADsafe library to make itself available
+//  to a widget. The library provides a name and a function. The result of
+//  calling that function will be made available to the widget via the name.
+
+        lib: function (name, f) {
+            if (!adsafe_id || reject_name(name)) {
+                error("ADsafe lib violation.");
+            }
+            adsafe_lib[name] = f(adsafe_lib);
+        },
+
+//  ADSAFE.log is a debugging aid that spams text to the browser's log.
+//  Overwrite this function to send log matter somewhere else.
+
+        log: function log(s) {
+            if (window.console) {
+                console.log(s);
+            } else if (typeof Debug === "object") {
+                Debug.writeln(s);      /* IE */
+            } else {
+                opera.postError(s);    /* Opera */
+            }
+        },
+
+//  ADSAFE.remove deletes a value from an object.
+
+        remove: function (object, name) {
+            if (!reject_property(object, name)) {
+                delete object[name];
+                return;
+            }
+            error();
+        },
+
+//  ADSAFE.set stores a value in an object.
+
+        set: function (object, name, value) {
+            reject_global(object);
+            if (!reject_property(object, name)) {
+                object[name] = value;
+                return;
+            }
+            error();
+        },
+
+//  ADSAFE._intercept allows the page to register a function that will
+//  see the widget's capabilities.
+
+        _intercept: function (f) {
+            interceptors.push(f);
+        }
+
+    };
+}());
diff --git a/samples/adsafe_dep.js b/samples/adsafe_dep.js
new file mode 100644
index 0000000..9db1012
--- /dev/null
+++ b/samples/adsafe_dep.js
@@ -0,0 +1,24 @@
+var document = 
+{       
+   defaultView:0,
+   selection:0,
+   getElementById:function(name)
+   {
+   },
+   createTextNode:function(appendage)
+   {
+	   
+   },
+   createDocumentFragment:function()
+   {
+	   
+   },
+   createElement:function(tag)
+   {
+	   
+   },
+   createDocumentFragment:function()
+   {
+	   
+   },
+}
diff --git a/samples/big.js b/samples/big.js
new file mode 100644
index 0000000..a3811c7
--- /dev/null
+++ b/samples/big.js
@@ -0,0 +1 @@
+;(function(GLOBAL){'use strict';var Big,DP=20,RM=1,MAX_DP=1E6,MAX_POWER=1E6,NE=-7,PE=21,NAME='[big.js] ',INVALID=NAME+'Invalid ',INVALID_DP=INVALID+'decimal places',INVALID_RM=INVALID+'rounding mode',DIV_BY_ZERO=NAME+'Division by zero',P={},UNDEFINED=void 0,NUMERIC=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;function _Big_(){function Big(n){var x=this;if(!(x instanceof Big))return n===UNDEFINED?_Big_():new Big(n);if(n instanceof Big){x.s=n.s;x.e=n.e;x.c=n.c.slice()}else{parse(x,n)}x.constructor=Big}Big.prototype=P;Big.DP=DP;Big.RM=RM;Big.NE=NE;Big.PE=PE;Big.version='5.0.2';return Big}function parse(x,n){var e,i,nl;if(n===0&&1/n<0)n='-0';else if(!NUMERIC.test(n+=''))throw Error(INVALID+'number');x.s=n.charAt(0)=='-'?(n=n.slice(1),-1):1;if((e=n.indexOf('.'))>-1)n=n.replace('.','');if((i=n.search(/e/i))>0){if(e<0)e=i;e+=+n.slice(i+1);n=n.substring(0,i)}else if(e<0){e=n.length}nl=n.length;for(i=0;i<nl&&n.charAt(i)=='0';)++i;if(i==nl){x.c=[x.e=0]}else{for(;nl>0&&n.charAt(--nl)=='0';);x.e=e-i-1;x.c=[];for(e=0;i<=nl;)x.c[e++]=+n.charAt(i++)}return x}function round(x,dp,rm,more){var xc=x.c,i=x.e+dp+1;if(i<xc.length){if(rm===1){more=xc[i]>=5}else if(rm===2){more=xc[i]>5||xc[i]==5&&(more||i<0||xc[i+1]!==UNDEFINED||xc[i-1]&1)}else if(rm===3){more=more||xc[i]!==UNDEFINED||i<0}else{more=false;if(rm!==0)throw Error(INVALID_RM);}if(i<1){xc.length=1;if(more){x.e=-dp;xc[0]=1}else{xc[0]=x.e=0}}else{xc.length=i--;if(more){for(;++xc[i]>9;){xc[i]=0;if(!i--){++x.e;xc.unshift(1)}}}for(i=xc.length;!xc[--i];)xc.pop()}}else if(rm<0||rm>3||rm!==~~rm){throw Error(INVALID_RM);}return x}function stringify(x,id,n,k){var e,s,Big=x.constructor,z=!x.c[0];if(n!==UNDEFINED){if(n!==~~n||n<(id==3)||n>MAX_DP){throw Error(id==3?INVALID+'precision':INVALID_DP);}x=new Big(x);n=k-x.e;if(x.c.length>++k)round(x,n,Big.RM);if(id==2)k=x.e+n+1;for(;x.c.length<k;)x.c.push(0)}e=x.e;s=x.c.join('');n=s.length;if(id!=2&&(id==1||id==3&&k<=e||e<=Big.NE||e>=Big.PE)){s=s.charAt(0)+(n>1?'.'+s.slice(1):'')+(e<0?'e':'e+')+e}else if(e<0){for(;++e;)s='0'+s;s='0.'+s}else if(e>0){if(++e>n)for(e-=n;e--;)s+='0';else if(e<n)s=s.slice(0,e)+'.'+s.slice(e)}else if(n>1){s=s.charAt(0)+'.'+s.slice(1)}return x.s<0&&(!z||id==4)?'-'+s:s}P.abs=function(){var x=new this.constructor(this);x.s=1;return x};P.cmp=function(y){var isneg,x=this,xc=x.c,yc=(y=new x.constructor(y)).c,i=x.s,j=y.s,k=x.e,l=y.e;if(!xc[0]||!yc[0])return!xc[0]?!yc[0]?0:-j:i;if(i!=j)return i;isneg=i<0;if(k!=l)return k>l^isneg?1:-1;j=(k=xc.length)<(l=yc.length)?k:l;for(i=-1;++i<j;){if(xc[i]!=yc[i])return xc[i]>yc[i]^isneg?1:-1}return k==l?0:k>l^isneg?1:-1};P.div=function(y){var x=this,Big=x.constructor,a=x.c,b=(y=new Big(y)).c,k=x.s==y.s?1:-1,dp=Big.DP;if(dp!==~~dp||dp<0||dp>MAX_DP)throw Error(INVALID_DP);if(!b[0])throw Error(DIV_BY_ZERO);if(!a[0])return new Big(k*0);var bl,bt,n,cmp,ri,bz=b.slice(),ai=bl=b.length,al=a.length,r=a.slice(0,bl),rl=r.length,q=y,qc=q.c=[],qi=0,d=dp+(q.e=x.e-y.e)+1;q.s=k;k=d<0?0:d;bz.unshift(0);for(;rl++<bl;)r.push(0);do{for(n=0;n<10;n++){if(bl!=(rl=r.length)){cmp=bl>rl?1:-1}else{for(ri=-1,cmp=0;++ri<bl;){if(b[ri]!=r[ri]){cmp=b[ri]>r[ri]?1:-1;break}}}if(cmp<0){for(bt=rl==bl?b:bz;rl;){if(r[--rl]<bt[rl]){ri=rl;for(;ri&&!r[--ri];)r[ri]=9;--r[ri];r[rl]+=10}r[rl]-=bt[rl]}for(;!r[0];)r.shift()}else{break}}qc[qi++]=cmp?n:++n;if(r[0]&&cmp)r[rl]=a[ai]||0;else r=[a[ai]]}while((ai++<al||r[0]!==UNDEFINED)&&k--);if(!qc[0]&&qi!=1){qc.shift();q.e--}if(qi>d)round(q,dp,Big.RM,r[0]!==UNDEFINED);return q};P.eq=function(y){return!this.cmp(y)};P.gt=function(y){return this.cmp(y)>0};P.gte=function(y){return this.cmp(y)>-1};P.lt=function(y){return this.cmp(y)<0};P.lte=function(y){return this.cmp(y)<1};P.minus=P.sub=function(y){var i,j,t,xlty,x=this,Big=x.constructor,a=x.s,b=(y=new Big(y)).s;if(a!=b){y.s=-b;return x.plus(y)}var xc=x.c.slice(),xe=x.e,yc=y.c,ye=y.e;if(!xc[0]||!yc[0]){return yc[0]?(y.s=-b,y):new Big(xc[0]?x:0)}if(a=xe-ye){if(xlty=a<0){a=-a;t=xc}else{ye=xe;t=yc}t.reverse();for(b=a;b--;)t.push(0);t.reverse()}else{j=((xlty=xc.length<yc.length)?xc:yc).length;for(a=b=0;b<j;b++){if(xc[b]!=yc[b]){xlty=xc[b]<yc[b];break}}}if(xlty){t=xc;xc=yc;yc=t;y.s=-y.s}if((b=(j=yc.length)-(i=xc.length))>0)for(;b--;)xc[i++]=0;for(b=i;j>a;){if(xc[--j]<yc[j]){for(i=j;i&&!xc[--i];)xc[i]=9;--xc[i];xc[j]+=10}xc[j]-=yc[j]}for(;xc[--b]===0;)xc.pop();for(;xc[0]===0;){xc.shift();--ye}if(!xc[0]){y.s=1;xc=[ye=0]}y.c=xc;y.e=ye;return y};P.mod=function(y){var ygtx,x=this,Big=x.constructor,a=x.s,b=(y=new Big(y)).s;if(!y.c[0])throw Error(DIV_BY_ZERO);x.s=y.s=1;ygtx=y.cmp(x)==1;x.s=a;y.s=b;if(ygtx)return new Big(x);a=Big.DP;b=Big.RM;Big.DP=Big.RM=0;x=x.div(y);Big.DP=a;Big.RM=b;return this.minus(x.times(y))};P.plus=P.add=function(y){var t,x=this,Big=x.constructor,a=x.s,b=(y=new Big(y)).s;if(a!=b){y.s=-b;return x.minus(y)}var xe=x.e,xc=x.c,ye=y.e,yc=y.c;if(!xc[0]||!yc[0])return yc[0]?y:new Big(xc[0]?x:a*0);xc=xc.slice();if(a=xe-ye){if(a>0){ye=xe;t=yc}else{a=-a;t=xc}t.reverse();for(;a--;)t.push(0);t.reverse()}if(xc.length-yc.length<0){t=yc;yc=xc;xc=t}a=yc.length;for(b=0;a;xc[a]%=10)b=(xc[--a]=xc[a]+yc[a]+b)/10|0;if(b){xc.unshift(b);++ye}for(a=xc.length;xc[--a]===0;)xc.pop();y.c=xc;y.e=ye;return y};P.pow=function(n){var x=this,one=new x.constructor(1),y=one,isneg=n<0;if(n!==~~n||n<-MAX_POWER||n>MAX_POWER)throw Error(INVALID+'exponent');if(isneg)n=-n;for(;;){if(n&1)y=y.times(x);n>>=1;if(!n)break;x=x.times(x)}return isneg?one.div(y):y};P.round=function(dp,rm){var Big=this.constructor;if(dp===UNDEFINED)dp=0;else if(dp!==~~dp||dp<0||dp>MAX_DP)throw Error(INVALID_DP);return round(new Big(this),dp,rm===UNDEFINED?Big.RM:rm)};P.sqrt=function(){var r,c,t,x=this,Big=x.constructor,s=x.s,e=x.e,half=new Big(0.5);if(!x.c[0])return new Big(x);if(s<0)throw Error(NAME+'No square root');s=Math.sqrt(x.toString());if(s===0||s===1/0){c=x.c.join('');if(!(c.length+e&1))c+='0';r=new Big(Math.sqrt(c).toString());r.e=((e+1)/2|0)-(e<0||e&1)}else{r=new Big(s.toString())}e=r.e+(Big.DP+=4);do{t=r;r=half.times(t.plus(x.div(t)))}while(t.c.slice(0,e).join('')!==r.c.slice(0,e).join(''));return round(r,Big.DP-=4,Big.RM)};P.times=P.mul=function(y){var c,x=this,Big=x.constructor,xc=x.c,yc=(y=new Big(y)).c,a=xc.length,b=yc.length,i=x.e,j=y.e;y.s=x.s==y.s?1:-1;if(!xc[0]||!yc[0])return new Big(y.s*0);y.e=i+j;if(a<b){c=xc;xc=yc;yc=c;j=a;a=b;b=j}for(c=new Array(j=a+b);j--;)c[j]=0;for(i=b;i--;){b=0;for(j=a+i;j>i;){b=c[j]+yc[i]*xc[j-i-1]+b;c[j--]=b%10;b=b/10|0}c[j]=(c[j]+b)%10}if(b)++y.e;else c.shift();for(i=c.length;!c[--i];)c.pop();y.c=c;return y};P.toExponential=function(dp){return stringify(this,1,dp,dp)};P.toFixed=function(dp){return stringify(this,2,dp,this.e+dp)};P.toPrecision=function(sd){return stringify(this,3,sd,sd-1)};P.toString=function(){return stringify(this)};P.valueOf=P.toJSON=function(){return stringify(this,4)};Big=_Big_();Big['default']=Big.Big=Big;if(typeof define==='function'&&define.amd){define(function(){return Big})}else if(typeof module!=='undefined'&&module.exports){module.exports=Big}else{GLOBAL.Big=Big}})(this);
\ No newline at end of file
diff --git a/samples/jslint.js b/samples/jslint.js
new file mode 100644
index 0000000..59eacdd
--- /dev/null
+++ b/samples/jslint.js
@@ -0,0 +1,5041 @@
+// jslint.js
+// 2018-01-04
+// Copyright (c) 2015 Douglas Crockford  (www.JSLint.com)
+
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+
+// The Software shall be used for Good, not Evil.
+
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+// jslint(source, option_object, global_array) is a function that takes 3
+// arguments. The second two arguments are optional.
+
+//      source          A text to analyze, a string or an array of strings.
+//      option_object   An object whose keys correspond to option names.
+//      global_array    An array of strings containing global variables that
+//                      the file is allowed readonly access.
+
+// jslint returns an object containing its results. The object contains a lot
+// of valuable information. It can be used to generate reports. The object
+// contains:
+
+//      directives: an array of directive comment tokens.
+//      edition: the version of JSLint that did the analysis.
+//      exports: the names exported from the module.
+//      froms: an array of strings representing each of the imports.
+//      functions: an array of objects that represent all of the functions
+//              declared in the file.
+//      global: an object representing the global object. Its .context property
+//              is an object containing a property for each global variable.
+//      id: "(JSLint)"
+//      json: true if the file is a JSON text.
+//      lines: an array of strings, the source.
+//      module: true if an import or export statement was used.
+//      ok: true if no warnings were generated. This is what you want.
+//      option: the option argument.
+//      property: a property object.
+//      stop: true if JSLint was unable to finish. You don't want this.
+//      tokens: an array of objects representing the tokens in the file.
+//      tree: the token objects arranged in a tree.
+//      warnings: an array of warning objects. A warning object can contain:
+//          name: "JSLintError"
+//          column: A column number in the file.
+//          line: A line number in the file.
+//          code: A warning code string.
+//          message: The warning message string.
+//          a: Exhibit A.
+//          b: Exhibit B.
+//          c: Exhibit C.
+//          d: Exhibit D.
+
+// jslint works in several phases. In any of these phases, errors might be
+// found. Sometimes JSLint is able to recover from an error and continue
+// parsing. In some cases, it cannot and will stop early. If that should happen,
+// repair your code and try again.
+
+// Phases:
+
+//      1. If the source is a single string, split it into an array of strings.
+//      2. Turn the source into an array of tokens.
+//      3. Furcate the tokens into a parse tree.
+//      4. Walk the tree, traversing all of the nodes of the tree. It is a
+//          recursive traversal. Each node may be processed on the way down
+//          (preaction) and on the way up (postaction).
+//      5. Check the whitespace between the tokens.
+
+// jslint can also examine JSON text. It decides that a file is JSON text if
+// the first token is "[" or "{". Processing of JSON text is much simpler than
+// the processing of JavaScript programs. Only the first three phases are
+// required.
+
+// WARNING: JSLint will hurt your feelings.
+
+/*jslint bitwise*/
+
+/*property
+    a, and, arity, assign, b, bad_assignment_a, bad_directive_a, bad_get,
+    bad_module_name_a, bad_option_a, bad_property_a, bad_set, bitwise, block,
+    body, browser, c, calls, catch, charCodeAt, closer, closure, code, column,
+    complex, concat, constant, context, convert, couch, create, d, dead,
+    default, devel, directive, directives, disrupt, dot, duplicate_a, edition,
+    ellipsis, else, empty_block, escape_mega, eval, every, expected_a,
+    expected_a_at_b_c, expected_a_b, expected_a_b_from_c_d,
+    expected_a_before_b, expected_a_next_at_b, expected_digits_after_a,
+    expected_four_digits, expected_identifier_a, expected_line_break_a_b,
+    expected_regexp_factor_a, expected_space_a_b, expected_statements_a,
+    expected_string_a, expected_type_string_a, exports, expression, extra,
+    finally, flag, for, forEach, free, from, froms, fud, fudge, function,
+    function_in_loop, functions, g, getset, global, i, id, identifier, import,
+    inc, indexOf, infix_in, init, initial, isArray, isFinite, join, json, keys,
+    label, label_a, lbp, led, length, level, line, lines, live, loop, m,
+    margin, match, maxerr, maxlen, message, misplaced_a, misplaced_directive_a,
+    missing_browser, missing_m, module, multivar, naked_block, name, names,
+    nested_comment, new, node, not_label_a, nr, nud, number_isNaN, ok, open,
+    option, out_of_scope_a, parameters, pop, property, push, qmark, quote,
+    redefinition_a_b, replace, required_a_optional_b, reserved_a, right, role,
+    search, signature, single, slice, some, sort, split, statement, stop,
+    strict, subscript_a, switch, test, this, thru, toString, todo_comment,
+    tokens, too_long, too_many, too_many_digits, tree, try, type, u,
+    unclosed_comment, unclosed_mega, unclosed_string, undeclared_a,
+    unexpected_a, unexpected_a_after_b, unexpected_a_before_b,
+    unexpected_at_top_level_a, unexpected_char_a, unexpected_comment,
+    unexpected_directive_a, unexpected_expression_a, unexpected_label_a,
+    unexpected_parens, unexpected_space_a_b, unexpected_statement_a,
+    unexpected_trailing_space, unexpected_typeof_a, uninitialized_a,
+    unreachable_a, unregistered_property_a, unsafe, unused_a, use_double,
+    use_spaces, use_strict, used, value, var_loop, var_switch, variable,
+    warning, warnings, weird_condition_a, weird_expression_a, weird_loop,
+    weird_relation_a, white, wrap_assignment, wrap_condition, wrap_immediate,
+    wrap_parameter, wrap_regexp, wrap_unary, wrapped, writable, y
+*/
+
+const jslint = (function JSLint() {
+    "use strict";
+
+    function empty() {
+
+// The empty function produces a new empty object that inherits nothing. This is
+// much better than {} because confusions around accidental method names like
+// "constructor" are completely avoided.
+
+        return Object.create(null);
+    }
+
+    function populate(object, array, value) {
+
+// Augment an object by taking property names from an array of strings.
+
+        array.forEach(function (name) {
+            object[name] = value;
+        });
+    }
+
+    const allowed_option = {
+
+// These are the options that are recognized in the option object or that may
+// appear in a /*jslint*/ directive. Most options will have a boolean value,
+// usually true. Some options will also predefine some number of global
+// variables.
+
+        bitwise: true,
+        browser: [
+            "clearInterval",
+            "clearTimeout",
+            "document",
+            "event",
+            "FileReader",
+            "FormData",
+            "history",
+            "localStorage",
+            "location",
+            "name",
+            "navigator",
+            "screen",
+            "sessionStorage",
+            "setInterval",
+            "setTimeout",
+            "Storage",
+            "URL",
+            "XMLHttpRequest"
+        ],
+        couch: [
+            "emit", "getRow", "isArray", "log", "provides", "registerType",
+            "require", "send", "start", "sum", "toJSON"
+        ],
+        convert: true,
+        devel: [
+            "alert", "confirm", "console", "prompt"
+        ],
+        eval: true,
+        for: true,
+        fudge: true,
+        getset: true,
+        maxerr: 10000,
+        maxlen: 10000,
+        multivar: true,
+        node: [
+            "Buffer", "clearImmediate", "clearInterval", "clearTimeout",
+            "console", "exports", "module", "process", "querystring",
+            "require", "setImmediate", "setInterval", "setTimeout",
+            "__dirname", "__filename"
+        ],
+        single: true,
+        this: true,
+        white: true
+    };
+
+    const spaceop = {
+
+// This is the set of infix operators that require a space on each side.
+
+        "!=": true,
+        "!==": true,
+        "%": true,
+        "%=": true,
+        "&": true,
+        "&=": true,
+        "&&": true,
+        "*": true,
+        "*=": true,
+        "+=": true,
+        "-=": true,
+        "/": true,
+        "/=": true,
+        "<": true,
+        "<=": true,
+        "<<": true,
+        "<<=": true,
+        "=": true,
+        "==": true,
+        "===": true,
+        "=>": true,
+        ">": true,
+        ">=": true,
+        ">>": true,
+        ">>=": true,
+        ">>>": true,
+        ">>>=": true,
+        "^": true,
+        "^=": true,
+        "|": true,
+        "|=": true,
+        "||": true
+    };
+
+    const bitwiseop = {
+
+// These are the bitwise operators.
+
+        "~": true,
+        "^": true,
+        "^=": true,
+        "&": true,
+        "&=": true,
+        "|": true,
+        "|=": true,
+        "<<": true,
+        "<<=": true,
+        ">>": true,
+        ">>=": true,
+        ">>>": true,
+        ">>>=": true
+    };
+
+    const opener = {
+
+// The open and close pairs.
+
+        "(": ")",       // paren
+        "[": "]",       // bracket
+        "{": "}",       // brace
+        "${": "}"       // mega
+    };
+
+    const relationop = {
+
+// The relational operators.
+
+        "!=": true,
+        "!==": true,
+        "==": true,
+        "===": true,
+        "<": true,
+        "<=": true,
+        ">": true,
+        ">=": true
+    };
+	
+//do not use these key. 2018-01-22
+//"Array", "ArrayBuffer", "Float32Array", "Float64Array", "Int8Array", "Int16Array",
+// "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "Date"
+
+//do not use these key. 2018-01-23
+//"DataView", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", 
+// "Generator", "GeneratorFunction", "Intl", "Promise", "Proxy", "Reflect", "System", 
+//"URIError", "WeakMap", "WeakSet"
+
+    const standard = [
+// These are the globals that are provided by the language standard.
+
+        "Boolean", 
+        "Error",
+        "EvalError",
+        "JSON", "Map", "Math", "Number", "Object", "parseInt", "parseFloat",
+        "RangeError", "ReferenceError", "RegExp",
+        "Set", "String", "Symbol", "SyntaxError", "TypeError"
+    ];
+	
+    //const useable_standard = ["print", "log"];
+	
+    const do_not_use_internal_func = ["internal_check_time", "internal_hello_test"];
+
+    const bundle = {
+
+// The bundle contains the raw text messages that are generated by jslint. It
+// seems that they are all error messages and warnings. There are no "Atta
+// boy!" or "You are so awesome!" messages. There is no positive reinforcement
+// or encouragement. This relentless negativity can undermine self-esteem and
+// wound the inner child. But if you accept it as sound advice rather than as
+// personal criticism, it can make your programs better.
+
+        and: "The '&&' subexpression should be wrapped in parens.",
+        bad_assignment_a: "Bad assignment to '{a}'.",
+        bad_directive_a: "Bad directive '{a}'.",
+        bad_get: "A get function takes no parameters.",
+        bad_module_name_a: "Bad module name '{a}'.",
+        bad_option_a: "Bad option '{a}'.",
+        bad_property_a: "Bad property name '{a}'.",
+        bad_set: "A set function takes one parameter.",
+        duplicate_a: "Duplicate '{a}'.",
+        empty_block: "Empty block.",
+        escape_mega: "Unexpected escapement in mega literal.",
+        expected_a: "Expected '{a}'.",
+        expected_a_at_b_c: "Expected '{a}' at column {b}, not column {c}.",
+        expected_a_b: "Expected '{a}' and instead saw '{b}'.",
+        expected_a_b_from_c_d: "Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",
+        expected_a_before_b: "Expected '{a}' before '{b}'.",
+        expected_a_next_at_b: "Expected '{a}' at column {b} on the next line.",
+        expected_digits_after_a: "Expected digits after '{a}'.",
+        expected_four_digits: "Expected four digits after '\\u'.",
+        expected_identifier_a: "Expected an identifier and instead saw '{a}'.",
+        expected_line_break_a_b: "Expected a line break between '{a}' and '{b}'.",
+        expected_regexp_factor_a: "Expected a regexp factor and instead saw '{a}'.",
+        expected_space_a_b: "Expected one space between '{a}' and '{b}'.",
+        expected_statements_a: "Expected statements before '{a}'.",
+        expected_string_a: "Expected a string and instead saw '{a}'.",
+        expected_type_string_a: "Expected a type string and instead saw '{a}'.",
+        function_in_loop: "Don't make functions within a loop.",
+        infix_in: "Unexpected 'in'. Compare with undefined, or use the hasOwnProperty method instead.",
+        label_a: "'{a}' is a statement label.",
+        misplaced_a: "Place '{a}' at the outermost level.",
+        misplaced_directive_a: "Place the '/*{a}*/' directive before the first statement.",
+        missing_browser: "/*global*/ requires the Assume a browser option.",
+        missing_m: "Expected 'm' flag on a multiline regular expression.",
+        naked_block: "Naked block.",
+        nested_comment: "Nested comment.",
+        not_label_a: "'{a}' is not a label.",
+        number_isNaN: "Use Number.isNaN function to compare with NaN.",
+        out_of_scope_a: "'{a}' is out of scope.",
+        redefinition_a_b: "Redefinition of '{a}' from line {b}.",
+        required_a_optional_b: "Required parameter '{a}' after optional parameter '{b}'.",
+        reserved_a: "Reserved name '{a}'.",
+        subscript_a: "['{a}'] is better written in dot notation.",
+        todo_comment: "Unexpected TODO comment.",
+        too_long: "Line too long.",
+        too_many: "Too many warnings.",
+        too_many_digits: "Too many digits.",
+        unclosed_comment: "Unclosed comment.",
+        unclosed_mega: "Unclosed mega literal.",
+        unclosed_string: "Unclosed string.",
+        undeclared_a: "Undeclared '{a}'.",
+        unexpected_a: "Unexpected '{a}'.",
+        unexpected_a_after_b: "Unexpected '{a}' after '{b}'.",
+        unexpected_a_before_b: "Unexpected '{a}' before '{b}'.",
+        unexpected_at_top_level_a: "Expected '{a}' to be in a function.",
+        unexpected_char_a: "Unexpected character '{a}'.",
+        unexpected_comment: "Unexpected comment.",
+        unexpected_directive_a: "When using modules, don't use directive '/*{a}'.",
+        unexpected_expression_a: "Unexpected expression '{a}' in statement position.",
+        unexpected_label_a: "Unexpected label '{a}'.",
+        unexpected_parens: "Don't wrap function literals in parens.",
+        unexpected_space_a_b: "Unexpected space between '{a}' and '{b}'.",
+        unexpected_statement_a: "Unexpected statement '{a}' in expression position.",
+        unexpected_trailing_space: "Unexpected trailing space.",
+        unexpected_typeof_a: "Unexpected 'typeof'. Use '===' to compare directly with {a}.",
+        uninitialized_a: "Uninitialized '{a}'.",
+        unreachable_a: "Unreachable '{a}'.",
+        unregistered_property_a: "Unregistered property name '{a}'.",
+        unsafe: "Unsafe character '{a}'.",
+        unused_a: "Unused '{a}'.",
+        use_double: "Use double quotes, not single quotes.",
+        use_spaces: "Use spaces, not tabs.",
+        use_strict: "This function needs a \"use strict\"; pragma.",
+        var_loop: "Don't declare variables in a loop.",
+        var_switch: "Don't declare variables in a switch.",
+        weird_condition_a: "Weird condition '{a}'.",
+        weird_expression_a: "Weird expression '{a}'.",
+        weird_loop: "Weird loop.",
+        weird_relation_a: "Weird relation '{a}'.",
+        wrap_assignment: "Don't wrap assignment statements in parens.",
+        wrap_condition: "Wrap the condition in parens.",
+        wrap_immediate: (
+            "Wrap an immediate function invocation in parentheses to assist "
+            + "the reader in understanding that the expression is the result "
+            + "of a function, and not the function itself."
+        ),
+        wrap_parameter: "Wrap the parameter in parens.",
+        wrap_regexp: "Wrap this regexp in parens to avoid confusion.",
+        wrap_unary: "Wrap the unary expression in parens."
+    };
+
+// Regular expression literals:
+
+// supplant {variables}
+    const rx_supplant = /\{([^{}]*)\}/g;
+// carriage return, carriage return linefeed, or linefeed
+    const rx_crlf = /\n|\r\n?/;
+// unsafe characters that are silently deleted by one or more browsers
+    const rx_unsafe = /[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;
+// identifier
+    const rx_identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;
+    const rx_module = /^[a-zA-Z0-9_$:.@\-\/]+$/;
+    const rx_bad_property = /^_|\$|Sync\$|_$/;
+// star slash
+    const rx_star_slash = /\*\//;
+// slash star
+    const rx_slash_star = /\/\*/;
+// slash star or ending slash
+    const rx_slash_star_or_slash = /\/\*|\/$/;
+// uncompleted work comment
+    const rx_todo = /\b(?:todo|TO\s?DO|HACK)\b/;
+// tab
+    const rx_tab = /\t/g;
+// directive
+    const rx_directive = /^(jslint|property|global)\s+(.*)$/;
+    const rx_directive_part = /^([a-zA-Z$_][a-zA-Z0-9$_]*)\s*(?::\s*(true|false|[0-9]+)\s*)?(?:,\s*)?(.*)$/;
+// token (sorry it is so long)
+    const rx_token = /^((\s+)|([a-zA-Z_$][a-zA-Z0-9_$]*)|[(){}\[\]?,:;'"~`]|=(?:==?|>)?|\.+|[*\/][*\/=]?|\+(?:=|\++)?|-(?:=|-+)?|[\^%]=?|&[&=]?|\|[|=]?|>{1,3}=?|<<?=?|!(?:!|==?)?|(0|[1-9][0-9]*))(.*)$/;
+    const rx_digits = /^([0-9]+)(.*)$/;
+    const rx_hexs = /^([0-9a-fA-F]+)(.*)$/;
+    const rx_octals = /^([0-7]+)(.*)$/;
+    const rx_bits = /^([01]+)(.*)$/;
+// mega
+    const rx_mega = /[`\\]|\$\{/;
+// indentation
+    const rx_colons = /^(.*)\?([:.]*)$/;
+    const rx_dot = /\.$/;
+// JSON number
+    const rx_JSON_number = /^-?\d+(?:\.\d*)?(?:e[\-+]?\d+)?$/i;
+// initial cap
+    const rx_cap = /^[A-Z]/;
+
+    function is_letter(string) {
+        return (
+            (string >= "a" && string <= "z\uffff")
+            || (string >= "A" && string <= "Z\uffff")
+        );
+    }
+
+    function supplant(string, object) {
+        return string.replace(rx_supplant, function (found, filling) {
+            const replacement = object[filling];
+            return (replacement !== undefined)
+                ? replacement
+                : found;
+        });
+    }
+
+    let anon = "anonymous"; // The guessed name for anonymous functions.
+    let blockage;           // The current block.
+    let block_stack;        // The stack of blocks.
+    let declared_globals;   // The object containing the global declarations.
+    let directives;         // The directive comments.
+    let directive_mode;     // true if directives are still allowed.
+    let early_stop;         // true if JSLint cannot finish.
+    let exports;            // The exported names and values.
+    let froms;              // The array collecting all import-from strings.
+    let fudge;              // true if the natural numbers start with 1.
+    let functionage;        // The current function.
+    let functions;          // The array containing all of the functions.
+    let global;             // The global object; the outermost context.
+    let json_mode;          // true if parsing JSON.
+    let lines;              // The array containing source lines.
+    let module_mode;        // true if import or export was used.
+    let next_token;         // The next token to be examined in the parse.
+    let option;             // The options parameter.
+    let property;           // The object containing the tallied property names.
+    let mega_mode;          // true if currently parsing a megastring literal.
+    let stack;              // The stack of functions.
+    let syntax;             // The object containing the parser.
+    let token;              // The current token being examined in the parse.
+    let token_nr;           // The number of the next token.
+    let tokens;             // The array of tokens.
+    let tenure;             // The predefined property registry.
+    let tree;               // The abstract parse tree.
+    let var_mode;           // "var" if using var; "let" if using let.
+    let warnings;           // The array collecting all generated warnings.
+
+// Error reportage functions:
+
+    function artifact(the_token) {
+
+// Return a string representing an artifact.
+
+        if (the_token === undefined) {
+            the_token = next_token;
+        }
+        return (the_token.id === "(string)" || the_token.id === "(number)")
+            ? String(the_token.value)
+            : the_token.id;
+    }
+
+    function artifact_line(the_token) {
+
+// Return the fudged line number of an artifact.
+
+        if (the_token === undefined) {
+            the_token = next_token;
+        }
+        return the_token.line + fudge;
+    }
+
+    function artifact_column(the_token) {
+
+// Return the fudged column number of an artifact.
+
+        if (the_token === undefined) {
+            the_token = next_token;
+        }
+        return the_token.from + fudge;
+    }
+
+    function warn_at(code, line, column, a, b, c, d) {
+
+// Report an error at some line and column of the program. The warning object
+// resembles an exception.
+
+        const warning = {         // ~~
+            name: "JSLintError",
+            column: column,
+            line: line,
+            code: code
+        };
+        if (a !== undefined) {
+            warning.a = a;
+        }
+        if (b !== undefined) {
+            warning.b = b;
+        }
+        if (c !== undefined) {
+            warning.c = c;
+        }
+        if (d !== undefined) {
+            warning.d = d;
+        }
+        warning.message = supplant(bundle[code] || code, warning);
+        warnings.push(warning);
+        return (
+            typeof option.maxerr === "number"
+            && warnings.length === option.maxerr
+        )   ? stop_at("too_many", line, column)
+            : warning;
+    }
+
+    function stop_at(code, line, column, a, b, c, d) {
+
+// Same as warn_at, except that it stops the analysis.
+
+        throw warn_at(code, line, column, a, b, c, d);
+    }
+
+    function warn(code, the_token, a, b, c, d) {
+
+// Same as warn_at, except the warning will be associated with a specific token.
+// If there is already a warning on this token, suppress the new one. It is
+// likely that the first warning will be the most meaningful.
+
+        if (the_token === undefined) {
+            the_token = next_token;
+        }
+        if (the_token.warning === undefined) {
+            the_token.warning = warn_at(
+                code,
+                the_token.line,
+                the_token.from,
+                a || artifact(the_token),
+                b,
+                c,
+                d
+            );
+            return the_token.warning;
+        }
+    }
+
+    function stop(code, the_token, a, b, c, d) {
+
+// Similar to warn and stop_at. If the token already had a warning, that
+// warning will be replaced with this new one. It is likely that the stopping
+// warning will be the more meaningful.
+
+        if (the_token === undefined) {
+            the_token = next_token;
+        }
+        delete the_token.warning;
+        throw warn(code, the_token, a, b, c, d);
+    }
+
+// Tokenize:
+
+    function tokenize(source) {
+
+// tokenize takes a source and produces from it an array of token objects.
+// JavaScript is notoriously difficult to tokenize because of the horrible
+// interactions between automatic semicolon insertion, regular expression
+// literals, and now megastring literals. JSLint benefits from eliminating
+// automatic semicolon insertion and nested megastring literals, which allows
+// full tokenization to precede parsing.
+
+// If the source is not an array, then it is split into lines at the
+// carriage return/linefeed.
+
+        lines = (Array.isArray(source))
+            ? source
+            : source.split(rx_crlf);
+        tokens = [];
+
+        let char;                   // a popular character
+        let column = 0;             // the column number of the next character
+        let first;                  // the first token
+        let from;                   // the starting column number of the token
+        let line = -1;              // the line number of the next character
+        let nr = 0;                 // the next token number
+        let previous = global;      // the previous token including comments
+        let prior = global;         // the previous token excluding comments
+        let mega_from;              // the starting column of megastring
+        let mega_line;              // the starting line of megastring
+        let snippet;                // a piece of string
+        let source_line;            // the current line source string
+
+        function next_line() {
+
+// Put the next line of source in source_line. If the line contains tabs,
+// replace them with spaces and give a warning. Also warn if the line contains
+// unsafe characters or is too damn long.
+
+            let at;
+            column = 0;
+            line += 1;
+            source_line = lines[line];
+            if (source_line !== undefined) {
+                at = source_line.search(rx_tab);
+                if (at >= 0) {
+                    if (!option.white) {
+                        warn_at("use_spaces", line, at + 1);
+                    }
+                    source_line = source_line.replace(rx_tab, " ");
+                }
+                at = source_line.search(rx_unsafe);
+                if (at >= 0) {
+                    warn_at(
+                        "unsafe",
+                        line,
+                        column + at,
+                        "U+" + source_line.charCodeAt(at).toString(16)
+                    );
+                }
+                if (option.maxlen && option.maxlen < source_line.length) {
+                    warn_at("too_long", line, source_line.length);
+                } else if (!option.white && source_line.slice(-1) === " ") {
+                    warn_at(
+                        "unexpected_trailing_space",
+                        line,
+                        source_line.length - 1
+                    );
+                }
+            }
+            return source_line;
+        }
+
+// Most tokens, including the identifiers, operators, and punctuators, can be
+// found with a regular expression. Regular expressions cannot correctly match
+// regular expression literals, so we will match those the hard way. String
+// literals and number literals can be matched by regular expressions, but they
+// don't provide good warnings. The functions snip, next_char, prev_char,
+// some_digits, and escape help in the parsing of literals.
+
+        function snip() {
+
+// Remove the last character from snippet.
+
+            snippet = snippet.slice(0, -1);
+        }
+
+        function next_char(match) {
+
+// Get the next character from the source line. Remove it from the source_line,
+// and append it to the snippet. Optionally check that the previous character
+// matched an expected value.
+
+            if (match !== undefined && char !== match) {
+                return stop_at(
+                    (char === "")
+                        ? "expected_a"
+                        : "expected_a_b",
+                    line,
+                    column - 1,
+                    match,
+                    char
+                );
+            }
+            if (source_line) {
+                char = source_line[0];
+                source_line = source_line.slice(1);
+                snippet += char;
+            } else {
+                char = "";
+                snippet += " ";
+            }
+            column += 1;
+            return char;
+        }
+
+        function back_char() {
+
+// Back up one character by moving a character from the end of the snippet to
+// the front of the source_line.
+
+            if (snippet) {
+                char = snippet.slice(-1);
+                source_line = char + source_line;
+                column -= 1;
+                snip();
+            } else {
+                char = "";
+            }
+            return char;
+        }
+
+        function some_digits(rx, quiet) {
+            const result = source_line.match(rx);
+            if (result) {
+                char = result[1];
+                column += char.length;
+                source_line = result[2];
+                snippet += char;
+            } else {
+                char = "";
+                if (!quiet) {
+                    warn_at(
+                        "expected_digits_after_a",
+                        line,
+                        column,
+                        snippet
+                    );
+                }
+            }
+            return char.length;
+        }
+
+        function escape(extra) {
+            switch (next_char("\\")) {
+            case "\\":
+            case "/":
+            case "`":
+            case "b":
+            case "f":
+            case "n":
+            case "r":
+            case "t":
+                break;
+            case "u":
+                if (next_char("u") === "{") {
+                    if (json_mode) {
+                        warn_at("unexpected_a", line, column - 1, char);
+                    }
+                    if (some_digits(rx_hexs) > 5) {
+                        warn_at("too_many_digits", line, column - 1);
+                    }
+                    if (next_char() !== "}") {
+                        stop_at("expected_a_before_b", line, column, "}", char);
+                    }
+                    next_char();
+                    return;
+                }
+                back_char();
+                if (some_digits(rx_hexs, true) < 4) {
+                    warn_at("expected_four_digits", line, column - 1);
+                }
+                break;
+            case "":
+                return stop_at("unclosed_string", line, column);
+            default:
+                if (!extra || extra.indexOf(char) < 0) {
+                    warn_at(
+                        "unexpected_a_before_b",
+                        line,
+                        column - 2,
+                        "\\",
+                        char
+                    );
+                }
+            }
+            next_char();
+        }
+
+        function make(id, value, identifier) {
+
+// Make the token object and append it to the tokens list.
+
+            const the_token = {
+                from: from,
+                id: id,
+                identifier: Boolean(identifier),
+                line: line,
+                nr: nr,
+                thru: column
+            };
+            tokens[nr] = the_token;
+            nr += 1;
+
+// Directives must appear before the first statement.
+
+            if (id !== "(comment)" && id !== ";") {
+                directive_mode = false;
+            }
+
+// If the token is to have a value, give it one.
+
+            if (value !== undefined) {
+                the_token.value = value;
+            }
+
+// If this token is an identifier that touches a preceding number, or
+// a "/", comment, or regular expression literal that touches a preceding
+// comment or regular expression literal, then give a missing space warning.
+// This warning is not suppressed by option.white.
+
+            if (
+                previous.line === line
+                && previous.thru === from
+                && (id === "(comment)" || id === "(regexp)" || id === "/")
+                && (previous.id === "(comment)" || previous.id === "(regexp)")
+            ) {
+                warn(
+                    "expected_space_a_b",
+                    the_token,
+                    artifact(previous),
+                    artifact(the_token)
+                );
+            }
+            if (previous.id === "." && id === "(number)") {
+                warn("expected_a_before_b", previous, "0", ".");
+            }
+            if (prior.id === "." && the_token.identifier) {
+                the_token.dot = true;
+            }
+
+// The previous token is used to detect adjacency problems.
+
+            previous = the_token;
+
+// The prior token is a previous token that was not a comment. The prior token
+// is used to disambiguate "/", which can mean division or regular expression
+// literal.
+
+            if (previous.id !== "(comment)") {
+                prior = previous;
+            }
+            return the_token;
+        }
+
+        function parse_directive(the_comment, body) {
+
+// JSLint recognizes three directives that can be encoded in comments. This
+// function processes one item, and calls itself recursively to process the
+// next one.
+
+            const result = body.match(rx_directive_part);
+            if (result) {
+                let allowed;
+                const name = result[1];
+                const value = result[2];
+                switch (the_comment.directive) {
+                case "jslint":
+                    allowed = allowed_option[name];
+                    switch (typeof allowed) {
+                    case "boolean":
+                    case "object":
+                        switch (value) {
+                        case "true":
+                        case "":
+                        case undefined:
+                            option[name] = true;
+                            if (Array.isArray(allowed)) {
+                                populate(declared_globals, allowed, false);
+                            }
+                            break;
+                        case "false":
+                            option[name] = false;
+                            break;
+                        default:
+                            warn(
+                                "bad_option_a",
+                                the_comment,
+                                name + ":" + value
+                            );
+                        }
+                        break;
+                    case "number":
+                        if (Number.isFinite(Number(value))) {
+                            option[name] = Number(value);
+                        } else {
+                            warn(
+                                "bad_option_a",
+                                the_comment,
+                                name + ":" + value
+                            );
+                        }
+                        break;
+                    default:
+                        warn("bad_option_a", the_comment, name);
+                    }
+                    break;
+                case "property":
+                    if (tenure === undefined) {
+                        tenure = empty();
+                    }
+                    tenure[name] = true;
+                    break;
+                case "global":
+                    if (value) {
+                        warn("bad_option_a", the_comment, name + ":" + value);
+                    }
+                    declared_globals[name] = false;
+                    module_mode = the_comment;
+                    break;
+                }
+                return parse_directive(the_comment, result[3]);
+            }
+            if (body) {
+                return stop("bad_directive_a", the_comment, body);
+            }
+        }
+
+        function comment(snippet) {
+
+// Make a comment object. Comments are not allowed in JSON text. Comments can
+// include directives and notices of incompletion.
+
+            const the_comment = make("(comment)", snippet);
+            if (Array.isArray(snippet)) {
+                snippet = snippet.join(" ");
+            }
+            if (!option.devel && rx_todo.test(snippet)) {
+                warn("todo_comment", the_comment);
+            }
+            const result = snippet.match(rx_directive);
+            if (result) {
+                if (!directive_mode) {
+                    warn_at("misplaced_directive_a", line, from, result[1]);
+                } else {
+                    the_comment.directive = result[1];
+                    parse_directive(the_comment, result[2]);
+                }
+                directives.push(the_comment);
+            }
+            return the_comment;
+        }
+
+        function regexp() {
+
+// Parse a regular expression literal.
+
+            let multi_mode = false;
+            let result;
+            let value;
+
+            function quantifier() {
+
+// Match an optional quantifier.
+
+                switch (char) {
+                case "?":
+                case "*":
+                case "+":
+                    next_char();
+                    break;
+                case "{":
+                    if (some_digits(rx_digits, true) === 0) {
+                        warn_at("expected_a", line, column, "0");
+                    }
+                    if (next_char() === ",") {
+                        some_digits(rx_digits, true);
+                        next_char();
+                    }
+                    next_char("}");
+                    break;
+                default:
+                    return;
+                }
+                if (char === "?") {
+                    next_char("?");
+                }
+            }
+
+            function subklass() {
+
+// Match a character in a character class.
+
+                switch (char) {
+                case "\\":
+                    escape("BbDdSsWw-[]^");
+                    return true;
+                case "[":
+                case "]":
+                case "/":
+                case "^":
+                case "-":
+                case "":
+                    return false;
+                case "`":
+                    if (mega_mode) {
+                        warn_at("unexpected_a", line, column, "`");
+                    }
+                    next_char();
+                    return true;
+                case " ":
+                    warn_at("expected_a_b", line, column, "\\u0020", " ");
+                    next_char();
+                    return true;
+                default:
+                    next_char();
+                    return true;
+                }
+            }
+
+            function ranges() {
+
+// Match a range of subclasses.
+
+                if (subklass()) {
+                    if (char === "-") {
+                        next_char("-");
+                        if (!subklass()) {
+                            return stop_at(
+                                "unexpected_a",
+                                line,
+                                column - 1,
+                                "-"
+                            );
+                        }
+                    }
+                    return ranges();
+                }
+            }
+
+            function klass() {
+
+// Match a class.
+
+                next_char("[");
+                if (char === "^") {
+                    next_char("^");
+                }
+                (function classy() {
+                    ranges();
+                    if (char !== "]" && char !== "") {
+                        warn_at(
+                            "expected_a_before_b",
+                            line,
+                            column,
+                            "\\",
+                            char
+                        );
+                        next_char();
+                        return classy();
+                    }
+                }());
+                next_char("]");
+            }
+
+            function choice() {
+
+                function group() {
+
+// Match a group that starts with left paren.
+
+                    next_char("(");
+                    if (char === "?") {
+                        next_char("?");
+                        switch (char) {
+                        case ":":
+                        case "=":
+                        case "!":
+                            next_char();
+                            break;
+                        default:
+                            next_char(":");
+                        }
+                    } else if (char === ":") {
+                        warn_at("expected_a_before_b", line, column, "?", ":");
+                    }
+                    choice();
+                    next_char(")");
+                }
+
+                function factor() {
+                    switch (char) {
+                    case "[":
+                        klass();
+                        return true;
+                    case "\\":
+                        escape("BbDdSsWw^${}[]():=!.-|*+?");
+                        return true;
+                    case "(":
+                        group();
+                        return true;
+                    case "?":
+                    case "+":
+                    case "*":
+                    case "}":
+                    case "{":
+                        warn_at("expected_a_before_b", line, column - 1, "\\", char);
+                        break;
+                    case "/":
+                    case "|":
+                    case "]":
+                    case ")":
+                    case "":
+                        return false;
+                    case "`":
+                        if (mega_mode) {
+                            warn_at("unexpected_a", line, column - 1, "`");
+                        }
+                        break;
+                    case " ":
+                        warn_at(
+                            "expected_a_b",
+                            line,
+                            column - 1,
+                            "\\s",
+                            " "
+                        );
+                        break;
+                    case "$":
+                        if (source_line[0] !== "/") {
+                            multi_mode = true;
+                        }
+                        break;
+                    case "^":
+                        if (snippet !== "^") {
+                            multi_mode = true;
+                        }
+                        break;
+                    }
+                    next_char();
+                    return true;
+                }
+
+                function sequence(follow) {
+                    if (factor()) {
+                        quantifier();
+                        return sequence(true);
+                    }
+                    if (!follow) {
+                        warn_at("expected_regexp_factor_a", line, column, char);
+                    }
+                }
+
+// Match a choice (a sequence that can be followed by | and another choice).
+
+                sequence();
+                if (char === "|") {
+                    next_char("|");
+                    return choice();
+                }
+            }
+
+// Scan the regexp literal. Give a warning if the first character is = because
+// /= looks like a division assignment operator.
+
+            snippet = "";
+            next_char();
+            if (char === "=") {
+                warn_at("expected_a_before_b", line, column, "\\", "=");
+            }
+            choice();
+
+// Make sure there is a closing slash.
+
+            snip();
+            value = snippet;
+            next_char("/");
+
+// Process dangling flag letters.
+
+            const allowed = {
+                g: true,
+                i: true,
+                m: true,
+                u: true,
+                y: true
+            };
+            const flag = empty();
+            (function make_flag() {
+                if (is_letter(char)) {
+                    if (allowed[char] !== true) {
+                        warn_at("unexpected_a", line, column, char);
+                    }
+                    allowed[char] = false;
+                    flag[char] = true;
+                    next_char();
+                    return make_flag();
+                }
+            }());
+            back_char();
+            if (char === "/" || char === "*") {
+                return stop_at("unexpected_a", line, from, char);
+            }
+            result = make("(regexp)", char);
+            result.flag = flag;
+            result.value = value;
+            if (multi_mode && !flag.m) {
+                warn_at("missing_m", line, column);
+            }
+            return result;
+        }
+
+        function string(quote) {
+
+// Make a string token.
+
+            let the_token;
+            snippet = "";
+            next_char();
+
+            return (function next() {
+                switch (char) {
+                case quote:
+                    snip();
+                    the_token = make("(string)", snippet);
+                    the_token.quote = quote;
+                    return the_token;
+                case "\\":
+                    escape(quote);
+                    break;
+                case "":
+                    return stop_at("unclosed_string", line, column);
+                case "`":
+                    if (mega_mode) {
+                        warn_at("unexpected_a", line, column, "`");
+                    }
+                    next_char("`");
+                    break;
+                default:
+                    next_char();
+                }
+                return next();
+            }());
+        }
+
+        function frack() {
+            if (char === ".") {
+                some_digits(rx_digits);
+                next_char();
+            }
+            if (char === "E" || char === "e") {
+                next_char();
+                if (char !== "+" && char !== "-") {
+                    back_char();
+                }
+                some_digits(rx_digits);
+                next_char();
+            }
+        }
+
+        function number() {
+            if (snippet === "0") {
+                switch (next_char()) {
+                case ".":
+                    frack();
+                    break;
+                case "b":
+                    some_digits(rx_bits);
+                    next_char();
+                    break;
+                case "o":
+                    some_digits(rx_octals);
+                    next_char();
+                    break;
+                case "x":
+                    some_digits(rx_hexs);
+                    next_char();
+                    break;
+                }
+            } else {
+                next_char();
+                frack();
+            }
+
+// If the next character after a number is a digit or letter, then something
+// unexpected is going on.
+
+            if (
+                (char >= "0" && char <= "9")
+                || (char >= "a" && char <= "z")
+                || (char >= "A" && char <= "Z")
+            ) {
+                return stop_at(
+                    "unexpected_a_after_b",
+                    line,
+                    column - 1,
+                    snippet.slice(-1),
+                    snippet.slice(0, -1)
+                );
+            }
+            back_char();
+            return make("(number)", snippet);
+        }
+
+        function lex() {
+            let array;
+            let i = 0;
+            let j = 0;
+            let last;
+            let result;
+            let the_token;
+            if (!source_line) {
+                source_line = next_line();
+                from = 0;
+                return (source_line === undefined)
+                    ? (mega_mode)
+                        ? stop_at("unclosed_mega", mega_line, mega_from)
+                        : make("(end)")
+                    : lex();
+            }
+            from = column;
+            result = source_line.match(rx_token);
+
+// result[1] token
+// result[2] whitespace
+// result[3] identifier
+// result[4] number
+// result[5] rest
+
+            if (!result) {
+                return stop_at(
+                    "unexpected_char_a",
+                    line,
+                    column,
+                    source_line[0]
+                );
+            }
+
+            snippet = result[1];
+            column += snippet.length;
+            source_line = result[5];
+
+// Whitespace was matched. Call lex again to get more.
+
+            if (result[2]) {
+                return lex();
+            }
+
+// The token is an identifier.
+
+            if (result[3]) {
+                return make(snippet, undefined, true);
+            }
+
+// The token is a number.
+
+            if (result[4]) {
+                return number(snippet);
+            }
+
+// The token is something miscellaneous.
+
+            switch (snippet) {
+
+// The token is a single or double quote string.
+
+            case "\"":
+                return string(snippet);
+
+            case "'":
+                if (!option.single) {
+                    warn_at("use_double", line, column);
+                }
+                return string(snippet);
+
+// The token is a megastring. We don't allow any kind of mega nesting.
+
+            case "`":
+                if (mega_mode) {
+                    return stop_at("expected_a_b", line, column, "}", "`");
+                }
+                snippet = "";
+                mega_from = from;
+                mega_line = line;
+                mega_mode = true;
+
+// Parsing a mega literal is tricky. First make a ` token.
+
+                make("`");
+                from += 1;
+
+// Then loop, building up a string, possibly from many lines, until seeing
+// the end of file, a closing `, or a ${ indicting an expression within the
+// string.
+
+                (function part() {
+                    const at = source_line.search(rx_mega);
+
+// If neither ` nor ${ is seen, then the whole line joins the snippet.
+
+                    if (at < 0) {
+                        snippet += source_line + "\n";
+                        return (next_line() === undefined)
+                            ? stop_at("unclosed_mega", mega_line, mega_from)
+                            : part();
+                    }
+
+// if either ` or ${ was found, then the preceding joins the snippet to become
+// a string token.
+
+                    snippet += source_line.slice(0, at);
+                    column += at;
+                    source_line = source_line.slice(at);
+                    if (source_line[0] === "\\") {
+                        stop_at("escape_mega", line, at);
+                    }
+                    make("(string)", snippet).quote = "`";
+                    snippet = "";
+
+// If ${, then make tokens that will become part of an expression until
+// a } token is made.
+
+                    if (source_line[0] === "$") {
+                        column += 2;
+                        make("${");
+                        source_line = source_line.slice(2);
+                        (function expr() {
+                            const id = lex().id;
+                            if (id === "{") {
+                                return stop_at(
+                                    "expected_a_b",
+                                    line,
+                                    column,
+                                    "}",
+                                    "{"
+                                );
+                            }
+                            if (id !== "}") {
+                                return expr();
+                            }
+                        }());
+                        return part();
+                    }
+                }());
+                source_line = source_line.slice(1);
+                column += 1;
+                mega_mode = false;
+                return make("`");
+
+// The token is a // comment.
+
+            case "//":
+                snippet = source_line;
+                source_line = "";
+                the_token = comment(snippet);
+                if (mega_mode) {
+                    warn("unexpected_comment", the_token, "`");
+                }
+                return the_token;
+
+// The token is a /* comment.
+
+            case "/*":
+                array = [];
+                if (source_line[0] === "/") {
+                    warn_at("unexpected_a", line, column + i, "/");
+                }
+                (function next() {
+                    if (source_line > "") {
+                        i = source_line.search(rx_star_slash);
+                        if (i >= 0) {
+                            return;
+                        }
+                        j = source_line.search(rx_slash_star);
+                        if (j >= 0) {
+                            warn_at("nested_comment", line, column + j);
+                        }
+                    }
+                    array.push(source_line);
+                    source_line = next_line();
+                    if (source_line === undefined) {
+                        return stop_at("unclosed_comment", line, column);
+                    }
+                    return next();
+                }());
+                snippet = source_line.slice(0, i);
+                j = snippet.search(rx_slash_star_or_slash);
+                if (j >= 0) {
+                    warn_at("nested_comment", line, column + j);
+                }
+                array.push(snippet);
+                column += i + 2;
+                source_line = source_line.slice(i + 2);
+                return comment(array);
+
+// The token is a slash.
+
+            case "/":
+
+// The / can be a division operator or the beginning of a regular expression
+// literal. It is not possible to know which without doing a complete parse.
+// We want to complete the tokenization before we begin to parse, so we will
+// estimate. This estimator can fail in some cases. For example, it cannot
+// know if "}" is ending a block or ending an object literal, so it can
+// behave incorrectly in that case; it is not meaningful to divide an
+// object, so it is likely that we can get away with it. We avoided the worst
+// cases by eliminating automatic semicolon insertion.
+
+                if (prior.identifier) {
+                    if (!prior.dot) {
+                        switch (prior.id) {
+                        case "return":
+                            return regexp();
+                        case "(begin)":
+                        case "case":
+                        case "delete":
+                        case "in":
+                        case "instanceof":
+                        case "new":
+                        case "typeof":
+                        case "void":
+                        case "yield":
+                            the_token = regexp();
+                            return stop("unexpected_a", the_token);
+                        }
+                    }
+                } else {
+                    last = prior.id[prior.id.length - 1];
+                    if ("(,=:?[".indexOf(last) >= 0) {
+                        return regexp();
+                    }
+                    if ("!&|{};~+-*%/^<>".indexOf(last) >= 0) {
+                        the_token = regexp();
+                        warn("wrap_regexp", the_token);
+                        return the_token;
+                    }
+                }
+                if (source_line[0] === "/") {
+                    column += 1;
+                    source_line = source_line.slice(1);
+                    snippet = "/=";
+                    warn_at("unexpected_a", line, column, "/=");
+                }
+                break;
+            }
+            return make(snippet);
+        }
+
+        first = lex();
+        json_mode = first.id === "{" || first.id === "[";
+
+// This is the only loop in JSLint. It will turn into a recursive call to lex
+// when ES6 has been finished and widely deployed and adopted.
+
+        while (true) {
+            if (lex().id === "(end)") {
+                break;
+            }
+        }
+    }
+
+// Parsing:
+
+// Parsing weaves the tokens into an abstract syntax tree. During that process,
+// a token may be given any of these properties:
+
+//      arity       string
+//      label       identifier
+//      name        identifier
+//      expression  expressions
+//      block       statements
+//      else        statements (else, default, catch)
+
+// Specialized tokens may have additional properties.
+
+    function survey(name) {
+        let id = name.id;
+
+// Tally the property name. If it is a string, only tally strings that conform
+// to the identifier rules.
+
+        if (id === "(string)") {
+            id = name.value;
+            if (!rx_identifier.test(id)) {
+                return id;
+            }
+        } else if (id === "`") {
+            if (name.value.length === 1) {
+                id = name.value[0].value;
+                if (!rx_identifier.test(id)) {
+                    return id;
+                }
+            }
+        } else if (!name.identifier) {
+            return stop("expected_identifier_a", name);
+        }
+
+// If we have seen this name before, increment its count.
+
+        if (typeof property[id] === "number") {
+            property[id] += 1;
+
+// If this is the first time seeing this property name, and if there is a
+// tenure list, then it must be on the list. Otherwise, it must conform to
+// the rules for good property names.
+
+        } else {
+            if (tenure !== undefined) {
+                if (tenure[id] !== true) {
+                    warn("unregistered_property_a", name);
+                }
+            } else {
+                if (name.identifier && rx_bad_property.test(id)) {
+                    warn("bad_property_a", name);
+                }
+            }
+            property[id] = 1;
+        }
+        return id;
+    }
+
+    function dispense() {
+
+// Deliver the next token, skipping the comments.
+
+        const cadet = tokens[token_nr];
+        token_nr += 1;
+        if (cadet.id === "(comment)") {
+            if (json_mode) {
+                warn("unexpected_a", cadet);
+            }
+            return dispense();
+        } else {
+            return cadet;
+        }
+    }
+
+    function lookahead() {
+
+// Look ahead one token without advancing.
+
+        const old_token_nr = token_nr;
+        const cadet = dispense(true);
+        token_nr = old_token_nr;
+        return cadet;
+    }
+
+    function advance(id, match) {
+
+// Produce the next token.
+
+// Attempt to give helpful names to anonymous functions.
+
+        if (token.identifier && token.id !== "function") {
+            anon = token.id;
+        } else if (token.id === "(string)" && rx_identifier.test(token.value)) {
+            anon = token.value;
+        }
+
+// Attempt to match next_token with an expected id.
+
+        if (id !== undefined && next_token.id !== id) {
+            return (match === undefined)
+                ? stop("expected_a_b", next_token, id, artifact())
+                : stop(
+                    "expected_a_b_from_c_d",
+                    next_token,
+                    id,
+                    artifact(match),
+                    artifact_line(match),
+                    artifact(next_token)
+                );
+        }
+
+// Promote the tokens, skipping comments.
+
+        token = next_token;
+        next_token = dispense();
+        if (next_token.id === "(end)") {
+            token_nr -= 1;
+        }
+    }
+
+// Parsing of JSON is simple:
+
+    function json_value() {
+        let negative;
+
+        function json_object() {
+            const brace = next_token;
+            const object = empty();
+            const properties = [];
+            brace.expression = properties;
+            advance("{");
+            if (next_token.id !== "}") {
+                (function next() {
+                    let name;
+                    let value;
+                    if (next_token.quote !== "\"") {
+                        warn("unexpected_a", next_token, next_token.quote);
+                    }
+                    name = next_token;
+                    advance("(string)");
+                    if (object[token.value] !== undefined) {
+                        warn("duplicate_a", token);
+                    } else if (token.value === "__proto__") {
+                        warn("bad_property_a", token);
+                    } else {
+                        object[token.value] = token;
+                    }
+                    advance(":");
+                    value = json_value();
+                    value.label = name;
+                    properties.push(value);
+                    if (next_token.id === ",") {
+                        advance(",");
+                        return next();
+                    }
+                }());
+            }
+            advance("}", brace);
+            return brace;
+        }
+
+        function json_array() {
+            const bracket = next_token;
+            const elements = [];
+            bracket.expression = elements;
+            advance("[");
+            if (next_token.id !== "]") {
+                (function next() {
+                    elements.push(json_value());
+                    if (next_token.id === ",") {
+                        advance(",");
+                        return next();
+                    }
+                }());
+            }
+            advance("]", bracket);
+            return bracket;
+        }
+
+        switch (next_token.id) {
+        case "{":
+            return json_object();
+        case "[":
+            return json_array();
+        case "true":
+        case "false":
+        case "null":
+            advance();
+            return token;
+        case "(number)":
+            if (!rx_JSON_number.test(next_token.value)) {
+                warn("unexpected_a");
+            }
+            advance();
+            return token;
+        case "(string)":
+            if (next_token.quote !== "\"") {
+                warn("unexpected_a", next_token, next_token.quote);
+            }
+            advance();
+            return token;
+        case "-":
+            negative = next_token;
+            negative.arity = "unary";
+            advance("-");
+            advance("(number)");
+            negative.expression = token;
+            return negative;
+        default:
+            stop("unexpected_a");
+        }
+    }
+
+// Now we parse JavaScript.
+
+    function enroll(name, role, readonly) {
+
+// Enroll a name into the current function context. The role can be exception,
+// function, label, parameter, or variable. We look for variable redefinition
+// because it causes confusion.
+
+        const id = name.id;
+
+// Reserved words may not be enrolled.
+
+        if (syntax[id] !== undefined && id !== "ignore") {
+            warn("reserved_a", name);
+        } else {
+
+// Has the name been enrolled in this context?
+
+            let earlier = functionage.context[id];
+            if (earlier) {
+                warn(
+                    "redefinition_a_b",
+                    name,
+                    name.id,
+                    earlier.line + fudge
+                );
+
+// Has the name been enrolled in an outer context?
+
+            } else {
+                stack.forEach(function (value) {
+                    const item = value.context[id];
+                    if (item !== undefined) {
+                        earlier = item;
+                    }
+                });
+                if (earlier) {
+                    if (id === "ignore") {
+                        if (earlier.role === "variable") {
+                            warn("unexpected_a", name);
+                        }
+                    } else {
+                        if (
+                            (
+                                role !== "exception"
+                                || earlier.role !== "exception"
+                            )
+                            && role !== "parameter"
+                            && role !== "function"
+                        ) {
+                            warn(
+                                "redefinition_a_b",
+                                name,
+                                name.id,
+                                earlier.line + fudge
+                            );
+                        }
+                    }
+                }
+
+// Enroll it.
+
+                functionage.context[id] = name;
+                name.dead = true;
+                name.function = functionage;
+                name.init = false;
+                name.role = role;
+                name.used = 0;
+                name.writable = !readonly;
+            }
+        }
+    }
+
+    function expression(rbp, initial) {
+
+// This is the heart of the Pratt parser. I retained Pratt's nomenclature.
+// They are elements of the parsing method called Top Down Operator Precedence.
+
+// nud     Null denotation
+// led     Left denotation
+// lbp     Left binding power
+// rbp     Right binding power
+
+// It processes a nud (variable, constant, prefix operator). It will then
+// process leds (infix operators) until the bind powers cause it to stop. It
+// returns the expression's parse tree.
+
+        let left;
+        let the_symbol;
+
+// Statements will have already advanced, so advance now only if the token is
+// not the first of a statement,
+
+        if (!initial) {
+            advance();
+        }
+        the_symbol = syntax[token.id];
+        if (the_symbol !== undefined && the_symbol.nud !== undefined) {
+            left = the_symbol.nud();
+        } else if (token.identifier) {
+            left = token;
+            left.arity = "variable";
+        } else {
+            return stop("unexpected_a", token);
+        }
+        (function right() {
+            the_symbol = syntax[next_token.id];
+            if (
+                the_symbol !== undefined
+                && the_symbol.led !== undefined
+                && rbp < the_symbol.lbp
+            ) {
+                advance();
+                left = the_symbol.led(left);
+                return right();
+            }
+        }());
+        return left;
+    }
+
+    function condition() {
+
+// Parse the condition part of a do, if, while.
+
+        const the_paren = next_token;
+        let the_value;
+        the_paren.free = true;
+        advance("(");
+        the_value = expression(0);
+        advance(")");
+        if (the_value.wrapped === true) {
+            warn("unexpected_a", the_paren);
+        }
+        switch (the_value.id) {
+        case "?":
+        case "~":
+        case "&":
+        case "|":
+        case "^":
+        case "<<":
+        case ">>":
+        case ">>>":
+        case "+":
+        case "-":
+        case "*":
+        case "/":
+        case "%":
+        case "typeof":
+        case "(number)":
+        case "(string)":
+            warn("unexpected_a", the_value);
+            break;
+        }
+        return the_value;
+    }
+
+    function is_weird(thing) {
+        return (
+            thing.id === "(regexp)"
+            || thing.id === "{"
+            || thing.id === "=>"
+            || thing.id === "function"
+            || (thing.id === "[" && thing.arity === "unary")
+        );
+    }
+
+    function are_similar(a, b) {
+        if (a === b) {
+            return true;
+        }
+        if (Array.isArray(a)) {
+            return (
+                Array.isArray(b)
+                && a.length === b.length
+                && a.every(function (value, index) {
+                    return are_similar(value, b[index]);
+                })
+            );
+        }
+        if (Array.isArray(b)) {
+            return false;
+        }
+        if (a.id === "(number)" && b.id === "(number)") {
+            return a.value === b.value;
+        }
+        let a_string;
+        let b_string;
+        if (a.id === "(string)") {
+            a_string = a.value;
+        } else if (a.id === "`" && a.constant) {
+            a_string = a.value[0];
+        }
+        if (b.id === "(string)") {
+            b_string = b.value;
+        } else if (b.id === "`" && b.constant) {
+            b_string = b.value[0];
+        }
+        if (typeof a_string === "string") {
+            return a_string === b_string;
+        }
+        if (is_weird(a) || is_weird(b)) {
+            return false;
+        }
+        if (a.arity === b.arity && a.id === b.id) {
+            if (a.id === ".") {
+                return (
+                    are_similar(a.expression, b.expression)
+                    && are_similar(a.name, b.name)
+                );
+            }
+            switch (a.arity) {
+            case "unary":
+                return are_similar(a.expression, b.expression);
+            case "binary":
+                return (
+                    a.id !== "("
+                    && are_similar(a.expression[0], b.expression[0])
+                    && are_similar(a.expression[1], b.expression[1])
+                );
+            case "ternary":
+                return (
+                    are_similar(a.expression[0], b.expression[0])
+                    && are_similar(a.expression[1], b.expression[1])
+                    && are_similar(a.expression[2], b.expression[2])
+                );
+            case "function":
+            case "regexp":
+                return false;
+            default:
+                return true;
+            }
+        }
+        return false;
+    }
+
+    function semicolon() {
+
+// Try to match a semicolon.
+
+        if (next_token.id === ";") {
+            advance(";");
+        } else {
+            warn_at(
+                "expected_a_b",
+                token.line,
+                token.thru,
+                ";",
+                artifact(next_token)
+            );
+        }
+        anon = "anonymous";
+    }
+
+    function statement() {
+
+// Parse a statement. Any statement may have a label, but only four statements
+// have use for one. A statement can be one of the standard statements, or
+// an assignment expression, or an invocation expression.
+
+        let first;
+        let the_label;
+        let the_statement;
+        let the_symbol;
+        advance();
+        if (token.identifier && next_token.id === ":") {
+            the_label = token;
+            if (the_label.id === "ignore") {
+                warn("unexpected_a", the_label);
+            }
+            advance(":");
+            switch (next_token.id) {
+            case "do":
+            case "for":
+            case "switch":
+            case "while":
+                enroll(the_label, "label", true);
+                the_label.init = true;
+                the_label.dead = false;
+                the_statement = statement();
+                the_statement.label = the_label;
+                the_statement.statement = true;
+                return the_statement;
+            default:
+                advance();
+                warn("unexpected_label_a", the_label);
+            }
+        }
+
+// Parse the statement.
+
+        first = token;
+        first.statement = true;
+        the_symbol = syntax[first.id];
+        if (the_symbol !== undefined && the_symbol.fud !== undefined) {
+            the_symbol.disrupt = false;
+            the_symbol.statement = true;
+            the_statement = the_symbol.fud();
+        } else {
+
+// It is an expression statement.
+
+            the_statement = expression(0, true);
+            if (the_statement.wrapped && the_statement.id !== "(") {
+                warn("unexpected_a", first);
+            }
+            semicolon();
+        }
+        if (the_label !== undefined) {
+            the_label.dead = true;
+        }
+        return the_statement;
+    }
+
+    function statements() {
+
+// Parse a list of statements. Give a warning if an unreachable statement
+// follows a disruptive statement.
+
+        const array = [];
+        (function next(disrupt) {
+            let a_statement;
+            switch (next_token.id) {
+            case "}":
+            case "case":
+            case "default":
+            case "else":
+            case "(end)":
+                break;
+            default:
+                a_statement = statement();
+                array.push(a_statement);
+                if (disrupt) {
+                    warn("unreachable_a", a_statement);
+                }
+                return next(a_statement.disrupt);
+            }
+        }(false));
+        return array;
+    }
+
+    function not_top_level(thing) {
+
+// Some features should not be at the outermost level.
+
+        if (functionage === global) {
+            warn("unexpected_at_top_level_a", thing);
+        }
+    }
+
+    function top_level_only(the_thing) {
+
+// Some features must be at the most outermost level.
+
+        if (blockage !== global) {
+            warn("misplaced_a", the_thing);
+        }
+    }
+
+    function block(special) {
+
+// Parse a block, a sequence of statements wrapped in braces.
+//  special "body"      The block is a function body.
+//          "ignore"    No warning on an empty block.
+//          "naked"     No advance.
+//          undefined   An ordinary block.
+
+        let stmts;
+        let the_block;
+        if (special !== "naked") {
+            advance("{");
+        }
+        the_block = token;
+        the_block.arity = "statement";
+        the_block.body = special === "body";
+
+// All top level function bodies should include the "use strict" pragma unless
+// the whole file is strict or the file is a module or the function parameters
+// use es6 syntax.
+
+        if (
+            special === "body"
+            && stack.length === 1
+            && next_token.value === "use strict"
+        ) {
+            the_block.strict = next_token;
+            next_token.statement = true;
+            advance("(string)");
+            advance(";");
+        }
+        stmts = statements();
+        the_block.block = stmts;
+        if (stmts.length === 0) {
+            if (!option.devel && special !== "ignore") {
+                warn("empty_block", the_block);
+            }
+            the_block.disrupt = false;
+        } else {
+            the_block.disrupt = stmts[stmts.length - 1].disrupt;
+        }
+        advance("}");
+        return the_block;
+    }
+
+    function mutation_check(the_thing) {
+
+// The only expressions that may be assigned to are
+//      e.b
+//      e[b]
+//      v
+//      [destructure]
+//      {destructure}
+
+        if (
+            the_thing.arity !== "variable"
+            && the_thing.id !== "."
+            && the_thing.id !== "["
+            && the_thing.id !== "{"
+        ) {
+            warn("bad_assignment_a", the_thing);
+            return false;
+        }
+        return true;
+    }
+
+    function left_check(left, right) {
+
+// Warn if the left is not one of these:
+//      e.b
+//      e[b]
+//      e()
+//      identifier
+
+        const id = left.id;
+        if (
+            !left.identifier
+            && (
+                left.arity !== "binary"
+                || (id !== "." && id !== "(" && id !== "[")
+            )
+        ) {
+            warn("unexpected_a", right);
+            return false;
+        }
+        return true;
+    }
+
+// These functions are used to specify the grammar of our language:
+
+    function symbol(id, bp) {
+
+// Make a symbol if it does not already exist in the language's syntax.
+
+        let the_symbol = syntax[id];
+        if (the_symbol === undefined) {
+            the_symbol = empty();
+            the_symbol.id = id;
+            the_symbol.lbp = bp || 0;
+            syntax[id] = the_symbol;
+        }
+        return the_symbol;
+    }
+
+    function assignment(id) {
+
+// Make an assignment operator. The one true assignment is different because
+// its left side, when it is a variable, is not treated as an expression.
+// That case is special because that is when a variable gets initialized. The
+// other assignment operators can modify, but they cannot initialize.
+
+        const the_symbol = symbol(id, 20);
+        the_symbol.led = function (left) {
+            const the_token = token;
+            let right;
+            the_token.arity = "assignment";
+            right = expression(20 - 1);
+            if (id === "=" && left.arity === "variable") {
+                the_token.names = left;
+                the_token.expression = right;
+            } else {
+                the_token.expression = [left, right];
+            }
+            switch (right.arity) {
+            case "assignment":
+            case "pre":
+            case "post":
+                warn("unexpected_a", right);
+                break;
+            }
+            mutation_check(left);
+            return the_token;
+        };
+        return the_symbol;
+    }
+
+    function constant(id, type, value) {
+
+// Make a constant symbol.
+
+        const the_symbol = symbol(id);
+        the_symbol.constant = true;
+        the_symbol.nud = (typeof value === "function")
+            ? value
+            : function () {
+                token.constant = true;
+                if (value !== undefined) {
+                    token.value = value;
+                }
+                return token;
+            };
+        the_symbol.type = type;
+        the_symbol.value = value;
+        return the_symbol;
+    }
+
+    function infix(id, bp, f) {
+
+// Make an infix operator.
+
+        const the_symbol = symbol(id, bp);
+        the_symbol.led = function (left) {
+            const the_token = token;
+            the_token.arity = "binary";
+            if (f !== undefined) {
+                return f(left);
+            }
+            the_token.expression = [left, expression(bp)];
+            return the_token;
+        };
+        return the_symbol;
+    }
+
+    function infixr(id, bp) {
+
+// Make a right associative infix operator.
+
+        const the_symbol = symbol(id, bp);
+        the_symbol.led = function (left) {
+            const the_token = token;
+            the_token.arity = "binary";
+            the_token.expression = [left, expression(bp - 1)];
+            return the_token;
+        };
+        return the_symbol;
+    }
+
+    function post(id) {
+
+// Make one of the post operators.
+
+        const the_symbol = symbol(id, 150);
+        the_symbol.led = function (left) {
+            token.expression = left;
+            token.arity = "post";
+            mutation_check(token.expression);
+            return token;
+        };
+        return the_symbol;
+    }
+
+    function pre(id) {
+
+// Make one of the pre operators.
+
+        const the_symbol = symbol(id);
+        the_symbol.nud = function () {
+            const the_token = token;
+            the_token.arity = "pre";
+            the_token.expression = expression(150);
+            mutation_check(the_token.expression);
+            return the_token;
+        };
+        return the_symbol;
+    }
+
+    function prefix(id, f) {
+
+// Make a prefix operator.
+
+        const the_symbol = symbol(id);
+        the_symbol.nud = function () {
+            const the_token = token;
+            the_token.arity = "unary";
+            if (typeof f === "function") {
+                return f();
+            }
+            the_token.expression = expression(150);
+            return the_token;
+        };
+        return the_symbol;
+    }
+
+    function stmt(id, f) {
+
+// Make a statement.
+
+        const the_symbol = symbol(id);
+        the_symbol.fud = function () {
+            token.arity = "statement";
+            return f();
+        };
+        return the_symbol;
+    }
+
+    function ternary(id1, id2) {
+
+// Make a ternary operator.
+
+        const the_symbol = symbol(id1, 30);
+        the_symbol.led = function (left) {
+            const the_token = token;
+            const second = expression(20);
+            advance(id2);
+            token.arity = "ternary";
+            the_token.arity = "ternary";
+            the_token.expression = [left, second, expression(10)];
+            return the_token;
+        };
+        return the_symbol;
+    }
+
+// Begin defining the language.
+
+    syntax = empty();
+
+    symbol("}");
+    symbol(")");
+    symbol("]");
+    symbol(",");
+    symbol(";");
+    symbol(":");
+    symbol("*/");
+    symbol("await");
+    symbol("case");
+    symbol("catch");
+    symbol("class");
+    symbol("default");
+    symbol("else");
+    symbol("enum");
+    symbol("finally");
+    symbol("implements");
+    symbol("interface");
+    symbol("package");
+    symbol("private");
+    symbol("protected");
+    symbol("public");
+    symbol("static");
+    symbol("super");
+    symbol("void");
+    symbol("yield");
+
+    constant("(number)", "number");
+    constant("(regexp)", "regexp");
+    constant("(string)", "string");
+    constant("arguments", "object", function () {
+        warn("unexpected_a", token);
+        return token;
+    });
+    constant("eval", "function", function () {
+        if (!option.eval) {
+            warn("unexpected_a", token);
+        } else if (next_token.id !== "(") {
+            warn("expected_a_before_b", next_token, "(", artifact());
+        }
+        return token;
+    });
+    //internal name 2018-01-23
+    do_not_use_internal_func.forEach(function (name) {
+        constant(name, "function", function () {
+            warn("unexpected_a", token);
+            return token;
+        });
+    });
+		
+    constant("false", "boolean", false);
+    constant("Function", "function", function () {
+        if (!option.eval) {
+            warn("unexpected_a", token);
+        } else if (next_token.id !== "(") {
+            warn("expected_a_before_b", next_token, "(", artifact());
+        }
+        return token;
+    });
+    constant("ignore", "undefined", function () {
+        warn("unexpected_a", token);
+        return token;
+    });
+    constant("Infinity", "number", Infinity);
+    constant("isFinite", "function", function () {
+        warn("expected_a_b", token, "Number.isFinite", "isFinite");
+        return token;
+    });
+    constant("isNaN", "function", function () {
+        warn("number_isNaN", token);
+        return token;
+    });
+    constant("NaN", "number", NaN);
+    constant("null", "null", null);
+    constant("this", "object", function () {
+        if (!option.this) {
+            warn("unexpected_a", token);
+        }
+        return token;
+    });
+    constant("true", "boolean", true);
+    constant("undefined", "undefined");
+
+    assignment("=");
+    assignment("+=");
+    assignment("-=");
+    assignment("*=");
+    assignment("/=");
+    assignment("%=");
+    assignment("&=");
+    assignment("|=");
+    assignment("^=");
+    assignment("<<=");
+    assignment(">>=");
+    assignment(">>>=");
+
+    infix("||", 40);
+    infix("&&", 50);
+    infix("|", 70);
+    infix("^", 80);
+    infix("&", 90);
+    infix("==", 100);
+    infix("===", 100);
+    infix("!=", 100);
+    infix("!==", 100);
+    infix("<", 110);
+    infix(">", 110);
+    infix("<=", 110);
+    infix(">=", 110);
+    infix("in", 110);
+    infix("instanceof", 110);
+    infix("<<", 120);
+    infix(">>", 120);
+    infix(">>>", 120);
+    infix("+", 130);
+    infix("-", 130);
+    infix("*", 140);
+    infix("/", 140);
+    infix("%", 140);
+    infixr("**", 150);
+    infix("(", 160, function (left) {
+        const the_paren = token;
+        let the_argument;
+        if (left.id !== "function") {
+            left_check(left, the_paren);
+        }
+        if (functionage.arity === "statement" && left.identifier) {
+            functionage.name.calls[left.id] = left;
+        }
+        the_paren.expression = [left];
+        if (next_token.id !== ")") {
+            (function next() {
+                let ellipsis;
+                if (next_token.id === "...") {
+                    ellipsis = true;
+                    advance("...");
+                }
+                the_argument = expression(10);
+                if (ellipsis) {
+                    the_argument.ellipsis = true;
+                }
+                the_paren.expression.push(the_argument);
+                if (next_token.id === ",") {
+                    advance(",");
+                    return next();
+                }
+            }());
+        }
+        advance(")", the_paren);
+        if (the_paren.expression.length === 2) {
+            the_paren.free = true;
+            if (the_argument.wrapped === true) {
+                warn("unexpected_a", the_paren);
+            }
+            if (the_argument.id === "(") {
+                the_argument.wrapped = true;
+            }
+        } else {
+            the_paren.free = false;
+        }
+        return the_paren;
+    });
+    infix(".", 170, function (left) {
+        const the_token = token;
+        const name = next_token;
+        if (
+            (
+                left.id !== "(string)"
+                || (name.id !== "indexOf" && name.id !== "repeat")
+            )
+            && (
+                left.id !== "["
+                || (
+                    name.id !== "concat"
+                    && name.id !== "forEach"
+                    && name.id !== "join"
+                    && name.id !== "map"
+                )
+            )
+            && (left.id !== "+" || name.id !== "slice")
+            && (
+                left.id !== "(regexp)"
+                || (name.id !== "exec" && name.id !== "test")
+            )
+        ) {
+            left_check(left, the_token);
+        }
+        if (!name.identifier) {
+            stop("expected_identifier_a");
+        }
+        advance();
+        survey(name);
+
+// The property name is not an expression.
+
+        the_token.name = name;
+        the_token.expression = left;
+        return the_token;
+    });
+    infix("[", 170, function (left) {
+        const the_token = token;
+        const the_subscript = expression(0);
+        if (the_subscript.id === "(string)" || the_subscript.id === "`") {
+            const name = survey(the_subscript);
+            if (rx_identifier.test(name)) {
+                warn("subscript_a", the_subscript, name);
+            }
+        }
+        left_check(left, the_token);
+        the_token.expression = [left, the_subscript];
+        advance("]");
+        return the_token;
+    });
+    infix("=>", 170, function (left) {
+        return stop("wrap_parameter", left);
+    });
+
+    function do_tick() {
+        const the_tick = token;
+        the_tick.value = [];
+        the_tick.expression = [];
+        if (next_token.id !== "`") {
+            (function part() {
+                advance("(string)");
+                the_tick.value.push(token);
+                if (next_token.id === "${") {
+                    advance("${");
+                    the_tick.expression.push(expression(0));
+                    advance("}");
+                    return part();
+                }
+            }());
+        }
+        advance("`");
+        return the_tick;
+    }
+
+    infix("`", 160, function (left) {
+        const the_tick = do_tick();
+        left_check(left, the_tick);
+        the_tick.expression = [left].concat(the_tick.expression);
+        return the_tick;
+    });
+
+    post("++");
+    post("--");
+    pre("++");
+    pre("--");
+
+    prefix("+");
+    prefix("-");
+    prefix("~");
+    prefix("!");
+    prefix("!!");
+    prefix("[", function () {
+        const the_token = token;
+        the_token.expression = [];
+        if (next_token.id !== "]") {
+            (function next() {
+                let element;
+                let ellipsis = false;
+                if (next_token.id === "...") {
+                    ellipsis = true;
+                    advance("...");
+                }
+                element = expression(10);
+                if (ellipsis) {
+                    element.ellipsis = true;
+                }
+                the_token.expression.push(element);
+                if (next_token.id === ",") {
+                    advance(",");
+                    return next();
+                }
+            }());
+        }
+        advance("]");
+        return the_token;
+    });
+    prefix("/=", function () {
+        stop("expected_a_b", token, "/\\=", "/=");
+    });
+    prefix("=>", function () {
+        return stop("expected_a_before_b", token, "()", "=>");
+    });
+    prefix("new", function () {
+        const the_new = token;
+        const right = expression(160);
+        if (next_token.id !== "(") {
+            warn("expected_a_before_b", next_token, "()", artifact(next_token));
+        }
+        the_new.expression = right;
+        return the_new;
+    });
+    prefix("typeof");
+    prefix("void", function () {
+        const the_void = token;
+        warn("unexpected_a", the_void);
+        the_void.expression = expression(0);
+        return the_void;
+    });
+
+    function parameter_list() {
+        let complex = false;
+        const list = [];
+        let optional;
+        const signature = ["("];
+        if (next_token.id !== ")" && next_token.id !== "(end)") {
+            (function parameter() {
+                let ellipsis = false;
+                let param;
+                if (next_token.id === "{") {
+                    complex = true;
+                    if (optional !== undefined) {
+                        warn(
+                            "required_a_optional_b",
+                            next_token,
+                            next_token.id,
+                            optional.id
+                        );
+                    }
+                    param = next_token;
+                    param.names = [];
+                    advance("{");
+                    signature.push("{");
+                    (function subparameter() {
+                        let subparam = next_token;
+                        if (!subparam.identifier) {
+                            return stop("expected_identifier_a");
+                        }
+                        survey(subparam);
+                        advance();
+                        signature.push(subparam.id);
+                        if (next_token.id === ":") {
+                            advance(":");
+                            advance();
+                            token.label = subparam;
+                            subparam = token;
+                            if (!subparam.identifier) {
+                                return stop("expected_identifier_a");
+                            }
+                        }
+                        param.names.push(subparam);
+                        if (next_token.id === ",") {
+                            advance(",");
+                            signature.push(", ");
+                            return subparameter();
+                        }
+                    }());
+                    list.push(param);
+                    advance("}");
+                    signature.push("}");
+                    if (next_token.id === ",") {
+                        advance(",");
+                        signature.push(", ");
+                        return parameter();
+                    }
+                } else if (next_token.id === "[") {
+                    complex = true;
+                    if (optional !== undefined) {
+                        warn(
+                            "required_a_optional_b",
+                            next_token,
+                            next_token.id,
+                            optional.id
+                        );
+                    }
+                    param = next_token;
+                    param.names = [];
+                    advance("[");
+                    signature.push("[]");
+                    (function subparameter() {
+                        const subparam = next_token;
+                        if (!subparam.identifier) {
+                            return stop("expected_identifier_a");
+                        }
+                        advance();
+                        param.names.push(subparam);
+                        if (next_token.id === ",") {
+                            advance(",");
+                            return subparameter();
+                        }
+                    }());
+                    list.push(param);
+                    advance("]");
+                    if (next_token.id === ",") {
+                        advance(",");
+                        signature.push(", ");
+                        return parameter();
+                    }
+                } else {
+                    if (next_token.id === "...") {
+                        complex = true;
+                        ellipsis = true;
+                        signature.push("...");
+                        advance("...");
+                        if (optional !== undefined) {
+                            warn(
+                                "required_a_optional_b",
+                                next_token,
+                                next_token.id,
+                                optional.id
+                            );
+                        }
+                    }
+                    if (!next_token.identifier) {
+                        return stop("expected_identifier_a");
+                    }
+                    param = next_token;
+                    list.push(param);
+                    advance();
+                    signature.push(param.id);
+                    if (ellipsis) {
+                        param.ellipsis = true;
+                    } else {
+                        if (next_token.id === "=") {
+                            complex = true;
+                            optional = param;
+                            advance("=");
+                            param.expression = expression(0);
+                        } else {
+                            if (optional !== undefined) {
+                                warn(
+                                    "required_a_optional_b",
+                                    param,
+                                    param.id,
+                                    optional.id
+                                );
+                            }
+                        }
+                        if (next_token.id === ",") {
+                            advance(",");
+                            signature.push(", ");
+                            return parameter();
+                        }
+                    }
+                }
+            }());
+        }
+        advance(")");
+        signature.push(")");
+        return [list, signature.join(""), complex];
+    }
+
+    function do_function(the_function) {
+        let name;
+        if (the_function === undefined) {
+            the_function = token;
+
+// A function statement must have a name that will be in the parent's scope.
+
+            if (the_function.arity === "statement") {
+                if (!next_token.identifier) {
+                    return stop("expected_identifier_a", next_token);
+                }
+                name = next_token;
+                enroll(name, "variable", true);
+                the_function.name = name;
+                name.init = true;
+                name.calls = empty();
+                advance();
+            } else if (name === undefined) {
+
+// A function expression may have an optional name.
+
+                if (next_token.identifier) {
+                    name = next_token;
+                    the_function.name = name;
+                    advance();
+                } else {
+                    the_function.name = anon;
+                }
+            }
+        } else {
+            name = the_function.name;
+        }
+        the_function.level = functionage.level + 1;
+        if (mega_mode) {
+            warn("unexpected_a", the_function);
+        }
+
+// Don't make functions in loops. It is inefficient, and it can lead to scoping
+// errors.
+
+        if (functionage.loop > 0) {
+            warn("function_in_loop", the_function);
+        }
+
+// Give the function properties for storing its names and for observing the
+// depth of loops and switches.
+
+        the_function.context = empty();
+        the_function.finally = 0;
+        the_function.loop = 0;
+        the_function.switch = 0;
+        the_function.try = 0;
+
+// Push the current function context and establish a new one.
+
+        stack.push(functionage);
+        functions.push(the_function);
+        functionage = the_function;
+        if (the_function.arity !== "statement" && typeof name === "object") {
+            enroll(name, "function", true);
+            name.dead = false;
+            name.init = true;
+            name.used = 1;
+        }
+
+// Parse the parameter list.
+
+        advance("(");
+        token.free = false;
+        token.arity = "function";
+        const pl = parameter_list();
+        functionage.parameters = pl[0];
+        functionage.signature = pl[1];
+        functionage.complex = pl[2];
+        functionage.parameters.forEach(function enroll_parameter(name) {
+            if (name.identifier) {
+                enroll(name, "parameter", false);
+            } else {
+                name.names.forEach(enroll_parameter);
+            }
+        });
+
+// The function's body is a block.
+
+        the_function.block = block("body");
+        if (
+            the_function.arity === "statement"
+            && next_token.line === token.line
+        ) {
+            return stop("unexpected_a", next_token);
+        }
+        if (next_token.id === "." || next_token.id === "[") {
+            warn("unexpected_a");
+        }
+
+// Restore the previous context.
+
+        functionage = stack.pop();
+        return the_function;
+    }
+
+    prefix("function", do_function);
+
+    function fart(pl) {
+        if (next_token.id === ";") {
+            stop("wrap_assignment", token);
+        }
+        advance("=>");
+        const the_fart = token;
+        the_fart.arity = "binary";
+        the_fart.name = "=>";
+        the_fart.level = functionage.level + 1;
+        functions.push(the_fart);
+        if (functionage.loop > 0) {
+            warn("function_in_loop", the_fart);
+        }
+
+// Give the function properties storing its names and for observing the depth
+// of loops and switches.
+
+        the_fart.context = empty();
+        the_fart.finally = 0;
+        the_fart.loop = 0;
+        the_fart.switch = 0;
+        the_fart.try = 0;
+
+// Push the current function context and establish a new one.
+
+        stack.push(functionage);
+        functionage = the_fart;
+        the_fart.parameters = pl[0];
+        the_fart.signature = pl[1];
+        the_fart.complex = true;
+        the_fart.parameters.forEach(function (name) {
+            enroll(name, "parameter", true);
+        });
+        if (next_token.id === "{") {
+            warn("expected_a_b", the_fart, "function", "=>");
+            the_fart.block = block("body");
+        } else {
+            the_fart.expression = expression(0);
+        }
+        functionage = stack.pop();
+        return the_fart;
+    }
+
+    prefix("(", function () {
+        const the_paren = token;
+        let the_value;
+        const cadet = lookahead().id;
+
+// We can distinguish between a parameter list for => and a wrapped expression
+// with one token of lookahead.
+
+        if (
+            next_token.id === ")"
+            || next_token.id === "..."
+            || (next_token.identifier && (cadet === "," || cadet === "="))
+        ) {
+            the_paren.free = false;
+            return fart(parameter_list());
+        }
+        the_paren.free = true;
+        the_value = expression(0);
+        if (the_value.wrapped === true) {
+            warn("unexpected_a", the_paren);
+        }
+        the_value.wrapped = true;
+        advance(")", the_paren);
+        if (next_token.id === "=>") {
+            if (the_value.arity !== "variable") {
+                if (the_value.id === "{" || the_value.id === "[") {
+                    warn("expected_a_before_b", the_paren, "function", "(");
+                    return stop("expected_a_b", next_token, "{", "=>");
+                }
+                return stop("expected_identifier_a", the_value);
+            }
+            the_paren.expression = [the_value];
+            return fart([the_paren.expression, "(" + the_value.id + ")"]);
+        }
+        return the_value;
+    });
+    prefix("`", do_tick);
+    prefix("{", function () {
+        const the_brace = token;
+        const seen = empty();
+        the_brace.expression = [];
+        if (next_token.id !== "}") {
+            (function member() {
+                let extra;
+                let full;
+                let id;
+                let name = next_token;
+                let value;
+                advance();
+                if (
+                    (name.id === "get" || name.id === "set")
+                    && next_token.identifier
+                ) {
+                    if (!option.getset) {
+                        warn("unexpected_a", name);
+                    }
+                    extra = name.id;
+                    full = extra + " " + next_token.id;
+                    name = next_token;
+                    advance();
+                    id = survey(name);
+                    if (seen[full] === true || seen[id] === true) {
+                        warn("duplicate_a", name);
+                    }
+                    seen[id] = false;
+                    seen[full] = true;
+                } else {
+                    id = survey(name);
+                    if (typeof seen[id] === "boolean") {
+                        warn("duplicate_a", name);
+                    }
+                    seen[id] = true;
+                }
+                if (name.identifier) {
+                    switch (next_token.id) {
+                    case "}":
+                    case ",":
+                        if (typeof extra === "string") {
+                            advance("(");
+                        }
+                        value = expression(Infinity, true);
+                        break;
+                    case "(":
+                        value = do_function({
+                            arity: "unary",
+                            from: name.from,
+                            id: "function",
+                            line: name.line,
+                            name: (typeof extra === "string")
+                                ? extra
+                                : id,
+                            thru: name.from
+                        });
+                        break;
+                    default:
+                        if (typeof extra === "string") {
+                            advance("(");
+                        }
+                        advance(":");
+                        value = expression(0);
+                    }
+                    value.label = name;
+                    if (typeof extra === "string") {
+                        value.extra = extra;
+                    }
+                    the_brace.expression.push(value);
+                } else {
+                    advance(":");
+                    value = expression(0);
+                    value.label = name;
+                    the_brace.expression.push(value);
+                }
+                if (next_token.id === ",") {
+                    advance(",");
+                    return member();
+                }
+            }());
+        }
+        advance("}");
+        return the_brace;
+    });
+
+    stmt(";", function () {
+        warn("unexpected_a", token);
+        return token;
+    });
+    stmt("{", function () {
+        warn("naked_block", token);
+        return block("naked");
+    });
+    stmt("break", function () {
+        const the_break = token;
+        let the_label;
+        if (
+            (functionage.loop < 1 && functionage.switch < 1)
+            || functionage.finally > 0
+        ) {
+            warn("unexpected_a", the_break);
+        }
+        the_break.disrupt = true;
+        if (next_token.identifier && token.line === next_token.line) {
+            the_label = functionage.context[next_token.id];
+            if (
+                the_label === undefined
+                || the_label.role !== "label"
+                || the_label.dead
+            ) {
+                warn((the_label !== undefined && the_label.dead)
+                    ? "out_of_scope_a"
+                    : "not_label_a");
+            } else {
+                the_label.used += 1;
+            }
+            the_break.label = next_token;
+            advance();
+        }
+        advance(";");
+        return the_break;
+    });
+
+    function do_var() {
+        const the_statement = token;
+        const is_const = the_statement.id === "const";
+        the_statement.names = [];
+
+// A program may use var or let, but not both.
+
+        if (!is_const) {
+            if (var_mode === undefined) {
+                var_mode = the_statement.id;
+            } else if (the_statement.id !== var_mode) {
+                warn(
+                    "expected_a_b",
+                    the_statement,
+                    var_mode,
+                    the_statement.id
+                );
+            }
+        }
+
+// We don't expect to see variables created in switch statements.
+
+        if (functionage.switch > 0) {
+            warn("var_switch", the_statement);
+        }
+        if (functionage.loop > 0 && the_statement.id === "var") {
+            warn("var_loop", the_statement);
+        }
+        (function next() {
+            if (next_token.id === "{" && the_statement.id !== "var") {
+                const the_brace = next_token;
+                the_brace.names = [];
+                advance("{");
+                (function pair() {
+                    if (!next_token.identifier) {
+                        return stop("expected_identifier_a", next_token);
+                    }
+                    const name = next_token;
+                    survey(name);
+                    advance();
+                    if (next_token.id === ":") {
+                        advance(":");
+                        if (!next_token.identifier) {
+                            return stop("expected_identifier_a", next_token);
+                        }
+                        next_token.label = name;
+                        the_brace.names.push(next_token);
+                        enroll(next_token, "variable", is_const);
+                        advance();
+                    } else {
+                        the_brace.names.push(name);
+                        enroll(name, "variable", is_const);
+                    }
+                    if (next_token.id === ",") {
+                        advance(",");
+                        return pair();
+                    }
+                }());
+                advance("}");
+                advance("=");
+                the_brace.expression = expression(0);
+                the_statement.names.push(the_brace);
+            } else if (next_token.id === "[" && the_statement.id !== "var") {
+                const the_bracket = next_token;
+                the_bracket.names = [];
+                advance("[");
+                (function element() {
+                    let ellipsis;
+                    if (next_token.id === "...") {
+                        ellipsis = true;
+                        advance("...");
+                    }
+                    if (!next_token.identifier) {
+                        return stop("expected_identifier_a", next_token);
+                    }
+                    const name = next_token;
+                    advance();
+                    the_bracket.names.push(name);
+                    enroll(name, "variable", the_statement.id === "const");
+                    if (ellipsis) {
+                        name.ellipsis = true;
+                    } else if (next_token.id === ",") {
+                        advance(",");
+                        return element();
+                    }
+                }());
+                advance("]");
+                advance("=");
+                the_bracket.expression = expression(0);
+                the_statement.names.push(the_bracket);
+            } else if (next_token.identifier) {
+                const name = next_token;
+                advance();
+                if (name.id === "ignore") {
+                    warn("unexpected_a", name);
+                }
+                enroll(name, "variable", is_const);
+                if (next_token.id === "=" || is_const) {
+                    advance("=");
+                    name.expression = expression(0);
+                    name.init = true;
+                }
+                the_statement.names.push(name);
+            } else {
+                return stop("expected_identifier_a", next_token);
+            }
+            if (next_token.id === ",") {
+                if (!option.multivar) {
+                    warn("expected_a_b", next_token, ";", ",");
+                }
+                advance(",");
+                return next();
+            }
+        }());
+        the_statement.open = (
+            the_statement.names.length > 1
+            && the_statement.line !== the_statement.names[1].line
+        );
+        semicolon();
+        return the_statement;
+    }
+
+    stmt("const", do_var);
+    stmt("continue", function () {
+        const the_continue = token;
+        if (functionage.loop < 1 || functionage.finally > 0) {
+            warn("unexpected_a", the_continue);
+        }
+        not_top_level(the_continue);
+        the_continue.disrupt = true;
+        warn("unexpected_a", the_continue);
+        advance(";");
+        return the_continue;
+    });
+    stmt("debugger", function () {
+        const the_debug = token;
+        if (!option.devel) {
+            warn("unexpected_a", the_debug);
+        }
+        semicolon();
+        return the_debug;
+    });
+    stmt("delete", function () {
+        const the_token = token;
+        const the_value = expression(0);
+        if (
+            (the_value.id !== "." && the_value.id !== "[")
+            || the_value.arity !== "binary"
+        ) {
+            stop("expected_a_b", the_value, ".", artifact(the_value));
+        }
+        the_token.expression = the_value;
+        semicolon();
+        return the_token;
+    });
+    stmt("do", function () {
+        const the_do = token;
+        not_top_level(the_do);
+        functionage.loop += 1;
+        the_do.block = block();
+        advance("while");
+        the_do.expression = condition();
+        semicolon();
+        if (the_do.block.disrupt === true) {
+            warn("weird_loop", the_do);
+        }
+        functionage.loop -= 1;
+        return the_do;
+    });
+    stmt("export", function () {
+        const the_export = token;
+        let the_id;
+        let the_name;
+        let the_thing;
+
+        function export_id() {
+            if (!next_token.identifier) {
+                stop("expected_identifier_a");
+            }
+            the_id = next_token.id;
+            the_name = global.context[the_id];
+            if (the_name === undefined) {
+                warn("unexpected_a");
+            } else {
+                the_name.used += 1;
+                if (exports[the_id] !== undefined) {
+                    warn("duplicate_a");
+                }
+                exports[the_id] = the_name;
+            }
+            advance();
+            the_export.expression.push(the_thing);
+        }
+
+        the_export.expression = [];
+        if (next_token.id === "default") {
+            if (exports.default !== undefined) {
+                warn("duplicate_a");
+            }
+            advance("default");
+            the_thing = expression(0);
+            semicolon();
+            exports.default = the_thing;
+            the_export.expression.push(the_thing);
+        } else {
+            switch (next_token.id) {
+            case "function":
+                the_thing = statement();
+                the_name = the_thing.name;
+                the_id = the_name.id;
+                the_name.used += 1;
+                if (exports[the_id] !== undefined) {
+                    warn("duplicate_a", the_name);
+                }
+                exports[the_id] = the_thing;
+                the_export.expression.push(the_thing);
+                the_thing.statement = false;
+                the_thing.arity = "unary";
+                break;
+            case "var":
+            case "let":
+            case "const":
+                warn("unexpected_a");
+                break;
+            case "{":
+                advance("{");
+                (function loop() {
+                    export_id();
+                    if (next_token.id === ",") {
+                        advance(",");
+                        return loop();
+                    }
+                }());
+                advance("}");
+                semicolon();
+                break;
+            default:
+                export_id();
+                if (the_name.writable !== true) {
+                    warn("unexpected_a", token);
+                }
+                semicolon();
+            }
+        }
+        module_mode = true;
+        return the_export;
+    });
+    stmt("for", function () {
+        let first;
+        const the_for = token;
+        if (!option.for) {
+            warn("unexpected_a", the_for);
+        }
+        not_top_level(the_for);
+        functionage.loop += 1;
+        advance("(");
+        token.free = true;
+        if (next_token.id === ";") {
+            return stop("expected_a_b", the_for, "while (", "for (;");
+        }
+        switch (next_token.id) {
+        case "var":
+        case "let":
+        case "const":
+            return stop("unexpected_a");
+        }
+        first = expression(0);
+        if (first.id === "in") {
+            if (first.expression[0].arity !== "variable") {
+                warn("bad_assignment_a", first.expression[0]);
+            }
+            the_for.name = first.expression[0];
+            the_for.expression = first.expression[1];
+            warn("expected_a_b", the_for, "Object.keys", "for in");
+        } else {
+            the_for.initial = first;
+            advance(";");
+            the_for.expression = expression(0);
+            advance(";");
+            the_for.inc = expression(0);
+            if (the_for.inc.id === "++") {
+                warn("expected_a_b", the_for.inc, "+= 1", "++");
+            }
+        }
+        advance(")");
+        the_for.block = block();
+        if (the_for.block.disrupt === true) {
+            warn("weird_loop", the_for);
+        }
+        functionage.loop -= 1;
+        return the_for;
+    });
+    stmt("function", do_function);
+    stmt("if", function () {
+        let the_else;
+        const the_if = token;
+        the_if.expression = condition();
+        the_if.block = block();
+        if (next_token.id === "else") {
+            advance("else");
+            the_else = token;
+            the_if.else = (next_token.id === "if")
+                ? statement()
+                : block();
+            if (the_if.block.disrupt === true) {
+                if (the_if.else.disrupt === true) {
+                    the_if.disrupt = true;
+                } else {
+                    warn("unexpected_a", the_else);
+                }
+            }
+        }
+        return the_if;
+    });
+    stmt("import", function () {
+        const the_import = token;
+        let name;
+        if (typeof module_mode === "object") {
+            warn("unexpected_directive_a", module_mode, module_mode.directive);
+        }
+        module_mode = true;
+        if (next_token.identifier) {
+            name = next_token;
+            advance();
+            if (name.id === "ignore") {
+                warn("unexpected_a", name);
+            }
+            enroll(name, "variable", true);
+            the_import.name = name;
+        } else {
+            const names = [];
+            advance("{");
+            if (next_token.id !== "}") {
+                while (true) {
+                    if (!next_token.identifier) {
+                        stop("expected_identifier_a");
+                    }
+                    name = next_token;
+                    advance();
+                    if (name.id === "ignore") {
+                        warn("unexpected_a", name);
+                    }
+                    enroll(name, "variable", true);
+                    names.push(name);
+                    if (next_token.id !== ",") {
+                        break;
+                    }
+                    advance(",");
+                }
+            }
+            advance("}");
+            the_import.name = names;
+        }
+        advance("from");
+        advance("(string)");
+        the_import.import = token;
+        if (!rx_module.test(token.value)) {
+            warn("bad_module_name_a", token);
+        }
+        froms.push(token.value);
+        semicolon();
+        return the_import;
+    });
+    stmt("let", do_var);
+    stmt("return", function () {
+        const the_return = token;
+        not_top_level(the_return);
+        if (functionage.finally > 0) {
+            warn("unexpected_a", the_return);
+        }
+        the_return.disrupt = true;
+        if (next_token.id !== ";" && the_return.line === next_token.line) {
+            the_return.expression = expression(10);
+        }
+        advance(";");
+        return the_return;
+    });
+    stmt("switch", function () {
+        let dups = [];
+        let last;
+        let stmts;
+        const the_cases = [];
+        let the_disrupt = true;
+        const the_switch = token;
+        not_top_level(the_switch);
+        if (functionage.finally > 0) {
+            warn("unexpected_a", the_switch);
+        }
+        functionage.switch += 1;
+        advance("(");
+        token.free = true;
+        the_switch.expression = expression(0);
+        the_switch.block = the_cases;
+        advance(")");
+        advance("{");
+        (function major() {
+            const the_case = next_token;
+            the_case.arity = "statement";
+            the_case.expression = [];
+            (function minor() {
+                advance("case");
+                token.switch = true;
+                const exp = expression(0);
+                if (dups.some(function (thing) {
+                    return are_similar(thing, exp);
+                })) {
+                    warn("unexpected_a", exp);
+                }
+                dups.push(exp);
+                the_case.expression.push(exp);
+                advance(":");
+                if (next_token.id === "case") {
+                    return minor();
+                }
+            }());
+            stmts = statements();
+            if (stmts.length < 1) {
+                warn("expected_statements_a");
+                return;
+            }
+            the_case.block = stmts;
+            the_cases.push(the_case);
+            last = stmts[stmts.length - 1];
+            if (last.disrupt) {
+                if (last.id === "break" && last.label === undefined) {
+                    the_disrupt = false;
+                }
+            } else {
+                warn(
+                    "expected_a_before_b",
+                    next_token,
+                    "break;",
+                    artifact(next_token)
+                );
+            }
+            if (next_token.id === "case") {
+                return major();
+            }
+        }());
+        dups = undefined;
+        if (next_token.id === "default") {
+            const the_default = next_token;
+            advance("default");
+            token.switch = true;
+            advance(":");
+            the_switch.else = statements();
+            if (the_switch.else.length < 1) {
+                warn("unexpected_a", the_default);
+                the_disrupt = false;
+            } else {
+                const the_last = the_switch.else[the_switch.else.length - 1];
+                if (the_last.id === "break" && the_last.label === undefined) {
+                    warn("unexpected_a", the_last);
+                    the_last.disrupt = false;
+                }
+                the_disrupt = the_disrupt && the_last.disrupt;
+            }
+        } else {
+            the_disrupt = false;
+        }
+        advance("}", the_switch);
+        functionage.switch -= 1;
+        the_switch.disrupt = the_disrupt;
+        return the_switch;
+    });
+    stmt("throw", function () {
+        const the_throw = token;
+        the_throw.disrupt = true;
+        the_throw.expression = expression(10);
+        semicolon();
+        return the_throw;
+    });
+    stmt("try", function () {
+        let the_catch;
+        let the_disrupt;
+        const the_try = token;
+        if (functionage.try > 0) {
+            warn("unexpected_a", the_try);
+        }
+        functionage.try += 1;
+        the_try.block = block();
+        the_disrupt = the_try.block.disrupt;
+        if (next_token.id === "catch") {
+            let ignored = "ignore";
+            the_catch = next_token;
+            the_try.catch = the_catch;
+            advance("catch");
+            advance("(");
+            if (!next_token.identifier) {
+                return stop("expected_identifier_a", next_token);
+            }
+            if (next_token.id !== "ignore") {
+                ignored = undefined;
+                the_catch.name = next_token;
+                enroll(next_token, "exception", true);
+            }
+            advance();
+            advance(")");
+            the_catch.block = block(ignored);
+            if (the_catch.block.disrupt !== true) {
+                the_disrupt = false;
+            }
+        } else {
+            warn(
+                "expected_a_before_b",
+                next_token,
+                "catch",
+                artifact(next_token)
+            );
+
+        }
+        if (next_token.id === "finally") {
+            functionage.finally += 1;
+            advance("finally");
+            the_try.else = block();
+            the_disrupt = the_try.else.disrupt;
+            functionage.finally -= 1;
+        }
+        the_try.disrupt = the_disrupt;
+        functionage.try -= 1;
+        return the_try;
+    });
+    stmt("var", do_var);
+    stmt("while", function () {
+        const the_while = token;
+        not_top_level(the_while);
+        functionage.loop += 1;
+        the_while.expression = condition();
+        the_while.block = block();
+        if (the_while.block.disrupt === true) {
+            warn("weird_loop", the_while);
+        }
+        functionage.loop -= 1;
+        return the_while;
+    });
+    stmt("with", function () {
+        stop("unexpected_a", token);
+    });
+
+    ternary("?", ":");
+
+// Ambulation of the parse tree.
+
+    function action(when) {
+
+// Produce a function that will register task functions that will be called as
+// the tree is traversed.
+
+        return function (arity, id, task) {
+            let a_set = when[arity];
+            let i_set;
+
+// The id parameter is optional. If excluded, the task will be applied to all
+// ids.
+
+            if (typeof id !== "string") {
+                task = id;
+                id = "(all)";
+            }
+
+// If this arity has no registrations yet, then create a set object to hold
+// them.
+
+            if (a_set === undefined) {
+                a_set = empty();
+                when[arity] = a_set;
+            }
+
+// If this id has no registrations yet, then create a set array to hold them.
+
+            i_set = a_set[id];
+            if (i_set === undefined) {
+                i_set = [];
+                a_set[id] = i_set;
+            }
+
+// Register the task with the arity and the id.
+
+            i_set.push(task);
+        };
+    }
+
+    function amble(when) {
+
+// Produce a function that will act on the tasks registered by an action
+// function while walking the tree.
+
+        return function (the_token) {
+
+// Given a task set that was built by an action function, run all of the
+// relevant tasks on the token.
+
+            let a_set = when[the_token.arity];
+            let i_set;
+
+// If there are tasks associated with the token's arity...
+
+            if (a_set !== undefined) {
+
+// If there are tasks associated with the token's id...
+
+                i_set = a_set[the_token.id];
+                if (i_set !== undefined) {
+                    i_set.forEach(function (task) {
+                        return task(the_token);
+                    });
+                }
+
+// If there are tasks for all ids.
+
+                i_set = a_set["(all)"];
+                if (i_set !== undefined) {
+                    i_set.forEach(function (task) {
+                        return task(the_token);
+                    });
+                }
+            }
+        };
+    }
+
+    const posts = empty();
+    const pres = empty();
+    const preaction = action(pres);
+    const postaction = action(posts);
+    const preamble = amble(pres);
+    const postamble = amble(posts);
+
+    function walk_expression(thing) {
+        if (thing) {
+            if (Array.isArray(thing)) {
+                thing.forEach(walk_expression);
+            } else {
+                preamble(thing);
+                walk_expression(thing.expression);
+                if (thing.id === "function") {
+                    walk_statement(thing.block);
+                }
+                switch (thing.arity) {
+                case "post":
+                case "pre":
+                    warn("unexpected_a", thing);
+                    break;
+                case "statement":
+                case "assignment":
+                    warn("unexpected_statement_a", thing);
+                    break;
+                }
+                postamble(thing);
+            }
+        }
+    }
+
+    function walk_statement(thing) {
+        if (thing) {
+            if (Array.isArray(thing)) {
+                thing.forEach(walk_statement);
+            } else {
+                preamble(thing);
+                walk_expression(thing.expression);
+                switch (thing.arity) {
+                case "statement":
+                case "assignment":
+                    break;
+                case "binary":
+                    if (thing.id !== "(") {
+                        warn("unexpected_expression_a", thing);
+                    }
+                    break;
+                default:
+                    warn((
+                        thing.id === "(string)"
+                        && thing.value === "use strict"
+                    )
+                        ? "unexpected_a"
+                        : "unexpected_expression_a", thing);
+                }
+                walk_statement(thing.block);
+                walk_statement(thing.else);
+                postamble(thing);
+            }
+        }
+    }
+
+    function lookup(thing) {
+        if (thing.arity === "variable") {
+
+// Look up the variable in the current context.
+
+            let the_variable = functionage.context[thing.id];
+
+// If it isn't local, search all the other contexts. If there are name
+// collisions, take the most recent.
+
+            if (the_variable === undefined) {
+                stack.forEach(function (outer) {
+                    const a_variable = outer.context[thing.id];
+                    if (
+                        a_variable !== undefined
+                        && a_variable.role !== "label"
+                    ) {
+                        the_variable = a_variable;
+                    }
+                });
+
+// If it isn't in any of those either, perhaps it is a predefined global.
+// If so, add it to the global context.
+
+                if (the_variable === undefined) {
+                    if (declared_globals[thing.id] === undefined) {
+                        warn("undeclared_a", thing);
+                        return;
+                    }
+                    the_variable = {
+                        dead: false,
+                        function: global,
+                        id: thing.id,
+                        init: true,
+                        role: "variable",
+                        used: 0,
+                        writable: false
+                    };
+                    global.context[thing.id] = the_variable;
+                }
+                the_variable.closure = true;
+                functionage.context[thing.id] = the_variable;
+            } else if (the_variable.role === "label") {
+                warn("label_a", thing);
+            }
+            if (the_variable.dead) {
+                warn("out_of_scope_a", thing);
+            }
+            return the_variable;
+        }
+    }
+
+    function subactivate(name) {
+        name.init = true;
+        name.dead = false;
+        blockage.live.push(name);
+    }
+
+    function preaction_function(thing) {
+        if (thing.arity === "statement" && blockage.body !== true) {
+            warn("unexpected_a", thing);
+        }
+        if (thing.level === 1) {
+            if (
+                module_mode === true
+                || global.strict !== undefined
+                || thing.complex
+            ) {
+                if (thing.id !== "=>" && thing.block.strict !== undefined) {
+                    warn("unexpected_a", thing.block.strict);
+                }
+            } else {
+                if (thing.block.strict === undefined) {
+                    warn("use_strict", thing);
+                }
+            }
+        }
+        stack.push(functionage);
+        block_stack.push(blockage);
+        functionage = thing;
+        blockage = thing;
+        thing.live = [];
+        if (typeof thing.name === "object") {
+            thing.name.dead = false;
+            thing.name.init = true;
+        }
+        switch (thing.extra) {
+        case "get":
+            if (thing.parameters.length !== 0) {
+                warn("bad_get", thing);
+            }
+            break;
+        case "set":
+            if (thing.parameters.length !== 1) {
+                warn("bad_set", thing);
+            }
+            break;
+        }
+        thing.parameters.forEach(function (name) {
+            walk_expression(name.expression);
+            if (name.id === "{" || name.id === "[") {
+                name.names.forEach(subactivate);
+            } else {
+                name.dead = false;
+                name.init = true;
+            }
+        });
+    }
+
+    function bitwise_check(thing) {
+        if (!option.bitwise && bitwiseop[thing.id] === true) {
+            warn("unexpected_a", thing);
+        }
+        if (
+            thing.id !== "("
+            && thing.id !== "&&"
+            && thing.id !== "||"
+            && thing.id !== "="
+            && Array.isArray(thing.expression)
+            && thing.expression.length === 2
+            && (
+                relationop[thing.expression[0].id] === true
+                || relationop[thing.expression[1].id] === true
+            )
+        ) {
+            warn("unexpected_a", thing);
+        }
+    }
+
+    function pop_block() {
+        blockage.live.forEach(function (name) {
+            name.dead = true;
+        });
+        delete blockage.live;
+        blockage = block_stack.pop();
+    }
+
+    function activate(name) {
+        if (name.expression !== undefined) {
+            walk_expression(name.expression);
+            if (name.id === "{" || name.id === "[") {
+                name.names.forEach(subactivate);
+            } else {
+                name.init = true;
+            }
+        }
+        name.dead = false;
+        blockage.live.push(name);
+    }
+
+    function action_var(thing) {
+        thing.names.forEach(activate);
+    }
+
+    preaction("assignment", bitwise_check);
+    preaction("binary", bitwise_check);
+    preaction("binary", function (thing) {
+        if (relationop[thing.id] === true) {
+            const left = thing.expression[0];
+            const right = thing.expression[1];
+            if (left.id === "NaN" || right.id === "NaN") {
+                warn("number_isNaN", thing);
+            } else if (left.id === "typeof") {
+                if (right.id !== "(string)") {
+                    if (right.id !== "typeof") {
+                        warn("expected_string_a", right);
+                    }
+                } else {
+                    const value = right.value;
+                    if (value === "null" || value === "undefined") {
+                        warn("unexpected_typeof_a", right, value);
+                    } else if (
+                        value !== "boolean"
+                        && value !== "function"
+                        && value !== "number"
+                        && value !== "object"
+                        && value !== "string"
+                        && value !== "symbol"
+                    ) {
+                        warn("expected_type_string_a", right, value);
+                    }
+                }
+            }
+        }
+    });
+    preaction("binary", "==", function (thing) {
+        warn("expected_a_b", thing, "===", "==");
+    });
+    preaction("binary", "!=", function (thing) {
+        warn("expected_a_b", thing, "!==", "!=");
+    });
+    preaction("binary", "=>", preaction_function);
+    preaction("binary", "||", function (thing) {
+        thing.expression.forEach(function (thang) {
+            if (thang.id === "&&" && !thang.wrapped) {
+                warn("and", thang);
+            }
+        });
+    });
+    preaction("binary", "(", function (thing) {
+        const left = thing.expression[0];
+        if (
+            left.identifier
+            && functionage.context[left.id] === undefined
+            && typeof functionage.name === "object"
+        ) {
+            const parent = functionage.name.function;
+            if (parent) {
+                const left_variable = parent.context[left.id];
+                if (
+                    left_variable !== undefined
+                    && left_variable.dead
+                    && left_variable.function === parent
+                    && left_variable.calls !== undefined
+                    && left_variable.calls[functionage.name.id] !== undefined
+                ) {
+                    left_variable.dead = false;
+                }
+            }
+        }
+    });
+    preaction("binary", "in", function (thing) {
+        warn("infix_in", thing);
+    });
+    preaction("binary", "instanceof", function (thing) {
+        warn("unexpected_a", thing);
+    });
+    preaction("binary", ".", function (thing) {
+        if (thing.expression.new) {
+            thing.new = true;
+        }
+    });
+    preaction("statement", "{", function (thing) {
+        block_stack.push(blockage);
+        blockage = thing;
+        thing.live = [];
+    });
+    preaction("statement", "for", function (thing) {
+        if (thing.name !== undefined) {
+            const the_variable = lookup(thing.name);
+            if (the_variable !== undefined) {
+                the_variable.init = true;
+                if (!the_variable.writable) {
+                    warn("bad_assignment_a", thing.name);
+                }
+            }
+        }
+        walk_statement(thing.initial);
+    });
+    preaction("statement", "function", preaction_function);
+    preaction("unary", "~", bitwise_check);
+    preaction("unary", "function", preaction_function);
+    preaction("variable", function (thing) {
+        const the_variable = lookup(thing);
+        if (the_variable !== undefined) {
+            thing.variable = the_variable;
+            the_variable.used += 1;
+        }
+    });
+
+    function init_variable(name) {
+        const the_variable = lookup(name);
+        if (the_variable !== undefined) {
+            if (the_variable.writable) {
+                the_variable.init = true;
+                return;
+            }
+        }
+        warn("bad_assignment_a", name);
+    }
+
+    postaction("assignment", "+=", function (thing) {
+        let right = thing.expression[1];
+        if (right.constant) {
+            if (
+                right.value === ""
+                || (right.id === "(number)" && right.value === "0")
+                || right.id === "(boolean)"
+                || right.id === "null"
+                || right.id === "undefined"
+                || Number.isNaN(right.value)
+            ) {
+                warn("unexpected_a", right);
+            }
+        }
+    });
+    postaction("assignment", function (thing) {
+
+// Assignment using = sets the init property of a variable. No other assignment
+// operator can do this. A = token keeps that variable (or array of variables
+// in case of destructuring) in its name property.
+
+        const lvalue = thing.expression[0];
+        if (thing.id === "=") {
+            if (thing.names !== undefined) {
+                if (Array.isArray(thing.names)) {
+                    thing.names.forEach(init_variable);
+                } else {
+                    init_variable(thing.names);
+                }
+            } else {
+                if (
+                    lvalue.id === "."
+                    && thing.expression[1].id === "undefined"
+                ) {
+                    warn(
+                        "expected_a_b",
+                        lvalue.expression,
+                        "delete",
+                        "undefined"
+                    );
+                }
+            }
+        } else {
+            if (lvalue.arity === "variable") {
+                if (!lvalue.variable || lvalue.variable.writable !== true) {
+                    warn("bad_assignment_a", lvalue);
+                }
+            }
+            const right = syntax[thing.expression[1].id];
+            if (
+                right !== undefined
+                && (
+                    right.id === "function"
+                    || right.id === "=>"
+                    || (
+                        right.constant
+                        && right.id !== "(number)"
+                        && (right.id !== "(string)" || thing.id !== "+=")
+                    )
+                )
+            ) {
+                warn("unexpected_a", thing.expression[1]);
+            }
+        }
+    });
+
+    function postaction_function(thing) {
+        delete functionage.finally;
+        delete functionage.loop;
+        delete functionage.switch;
+        delete functionage.try;
+        functionage = stack.pop();
+        if (thing.wrapped) {
+            warn("unexpected_parens", thing);
+        }
+        return pop_block();
+    }
+
+    postaction("binary", function (thing) {
+        let right;
+        if (relationop[thing.id]) {
+            if (
+                is_weird(thing.expression[0])
+                || is_weird(thing.expression[1])
+                || are_similar(thing.expression[0], thing.expression[1])
+                || (
+                    thing.expression[0].constant === true
+                    && thing.expression[1].constant === true
+                )
+            ) {
+                warn("weird_relation_a", thing);
+            }
+        }
+        switch (thing.id) {
+        case "+":
+            if (!option.convert) {
+                if (thing.expression[0].value === "") {
+                    warn("expected_a_b", thing, "String(...)", "\"\" +");
+                } else if (thing.expression[1].value === "") {
+                    warn("expected_a_b", thing, "String(...)", "+ \"\"");
+                }
+            }
+            break;
+        case "=>":
+        case "(":
+        case "[":
+            break;
+        case ".":
+            if (thing.expression.id === "RegExp") {
+                warn("weird_expression_a", thing);
+            }
+            break;
+        default:
+            right = thing.expression[1];
+            if (
+                (thing.id === "+" || thing.id === "-")
+                && right.id === thing.id
+                && right.arity === "unary"
+                && !right.wrapped
+            ) {
+                warn("wrap_unary", right);
+            }
+            if (
+                thing.expression[0].constant === true
+                && right.constant === true
+            ) {
+                thing.constant = true;
+            }
+        }
+    });
+    postaction("binary", "&&", function (thing) {
+        if (
+            is_weird(thing.expression[0])
+            || are_similar(thing.expression[0], thing.expression[1])
+            || thing.expression[0].constant === true
+            || thing.expression[1].constant === true
+        ) {
+            warn("weird_condition_a", thing);
+        }
+    });
+    postaction("binary", "||", function (thing) {
+        if (
+            is_weird(thing.expression[0])
+            || are_similar(thing.expression[0], thing.expression[1])
+            || thing.expression[0].constant === true
+        ) {
+            warn("weird_condition_a", thing);
+        }
+    });
+    postaction("binary", "=>", postaction_function);
+    postaction("binary", "(", function (thing) {
+        let left = thing.expression[0];
+        let the_new;
+        let arg;
+        if (left.id === "new") {
+            the_new = left;
+            left = left.expression;
+        }
+        if (left.id === "function") {
+            if (!thing.wrapped) {
+                warn("wrap_immediate", thing);
+            }
+        } else if (left.identifier) {
+            if (the_new !== undefined) {
+                if (
+                    left.id[0] > "Z"
+                    || left.id === "Boolean"
+                    || left.id === "Number"
+                    || left.id === "String"
+                    || left.id === "Symbol"
+                ) {
+                    warn("unexpected_a", the_new);
+                } else if (left.id === "Function") {
+                    if (!option.eval) {
+                        warn("unexpected_a", left, "new Function");
+                    }
+                } else if (left.id === "Array") {
+                    arg = thing.expression;
+                    if (
+                        arg.length !== 2
+                        || (
+                            (
+                                arg[1].id !== "(number)"
+                                || Number(arg[1].value) !== (arg[1].value | 0)
+                            )
+                            && arg[1].arity !== "binary"
+                        )
+                    ) {
+                        warn("expected_a_b", left, "[]", "new Array");
+                    }
+                } else if (left.id === "Object") {
+                    warn(
+                        "expected_a_b",
+                        left,
+                        "Object.create(null)",
+                        "new Object"
+                    );
+                }
+            } else {
+                if (
+                    left.id[0] >= "A"
+                    && left.id[0] <= "Z"
+                    && left.id !== "Boolean"
+                    && left.id !== "Number"
+                    && left.id !== "String"
+                    && left.id !== "Symbol"
+                ) {
+                    warn(
+                        "expected_a_before_b",
+                        left,
+                        "new",
+                        artifact(left)
+                    );
+                }
+            }
+        } else if (left.id === ".") {
+            let cack = the_new !== undefined;
+            if (left.expression.id === "Date" && left.name.id === "UTC") {
+                cack = !cack;
+            }
+            if (rx_cap.test(left.name.id) !== cack) {
+                if (the_new !== undefined) {
+                    warn("unexpected_a", the_new);
+                } else {
+                    warn(
+                        "expected_a_before_b",
+                        left.expression,
+                        "new",
+                        left.name.id
+                    );
+                }
+            }
+            if (left.name.id === "getTime") {
+                const paren = left.expression;
+                if (paren.id === "(") {
+                    const array = paren.expression;
+                    if (array.length === 1) {
+                        const new_date = array[0];
+                        if (
+                            new_date.id === "new"
+                            && new_date.expression.id === "Date"
+                        ) {
+                            warn(
+                                "expected_a_b",
+                                new_date,
+                                "Date.now()",
+                                "new Date().getTime()"
+                            );
+                        }
+                    }
+                }
+            }
+        }
+    });
+    postaction("binary", "[", function (thing) {
+        if (thing.expression[0].id === "RegExp") {
+            warn("weird_expression_a", thing);
+        }
+        if (is_weird(thing.expression[1])) {
+            warn("weird_expression_a", thing.expression[1]);
+        }
+    });
+    postaction("statement", "{", pop_block);
+    postaction("statement", "const", action_var);
+    postaction("statement", "export", top_level_only);
+    postaction("statement", "for", function (thing) {
+        walk_statement(thing.inc);
+    });
+    postaction("statement", "function", postaction_function);
+    postaction("statement", "import", function (the_thing) {
+        const name = the_thing.name;
+        if (Array.isArray(name)) {
+            name.forEach(function (name) {
+                name.dead = false;
+                name.init = true;
+                blockage.live.push(name);
+            });
+        } else {
+            name.dead = false;
+            name.init = true;
+            blockage.live.push(name);
+        }
+        return top_level_only(the_thing);
+    });
+    postaction("statement", "let", action_var);
+    postaction("statement", "try", function (thing) {
+        if (thing.catch !== undefined) {
+            const the_name = thing.catch.name;
+            if (the_name !== undefined) {
+                const the_variable = functionage.context[the_name.id];
+                the_variable.dead = false;
+                the_variable.init = true;
+            }
+            walk_statement(thing.catch.block);
+        }
+    });
+    postaction("statement", "var", action_var);
+    postaction("ternary", function (thing) {
+        if (
+            is_weird(thing.expression[0])
+            || thing.expression[0].constant === true
+            || are_similar(thing.expression[1], thing.expression[2])
+        ) {
+            warn("unexpected_a", thing);
+        } else if (are_similar(thing.expression[0], thing.expression[1])) {
+            warn("expected_a_b", thing, "||", "?");
+        } else if (are_similar(thing.expression[0], thing.expression[2])) {
+            warn("expected_a_b", thing, "&&", "?");
+        } else if (
+            thing.expression[1].id === "true"
+            && thing.expression[2].id === "false"
+        ) {
+            warn("expected_a_b", thing, "!!", "?");
+        } else if (
+            thing.expression[1].id === "false"
+            && thing.expression[2].id === "true"
+        ) {
+            warn("expected_a_b", thing, "!", "?");
+        } else if (
+            thing.expression[0].wrapped !== true
+            && (
+                thing.expression[0].id === "||"
+                || thing.expression[0].id === "&&"
+            )
+        ) {
+            warn("wrap_condition", thing.expression[0]);
+        }
+    });
+    postaction("unary", function (thing) {
+        switch (thing.id) {
+        case "[":
+        case "{":
+        case "function":
+        case "new":
+            break;
+        case "`":
+            if (thing.expression.every(function (thing) {
+                return thing.constant;
+            })) {
+                thing.constant = true;
+            }
+            break;
+        case "!":
+            if (thing.expression.constant === true) {
+                warn("unexpected_a", thing);
+            }
+            break;
+        case "!!":
+            if (!option.convert) {
+                warn("expected_a_b", thing, "Boolean(...)", "!!");
+            }
+            break;
+        default:
+            if (thing.expression.constant === true) {
+                thing.constant = true;
+            }
+        }
+    });
+    postaction("unary", "function", postaction_function);
+    postaction("unary", "+", function (thing) {
+        if (!option.convert) {
+            warn("expected_a_b", thing, "Number(...)", "+");
+        }
+        const right = thing.expression;
+        if (right.id === "(" && right.expression[0].id === "new") {
+            warn("unexpected_a_before_b", thing, "+", "new");
+        } else if (
+            right.constant
+            || right.id === "{"
+            || (right.id === "[" && right.arity !== "binary")
+        ) {
+            warn("unexpected_a", thing, "+");
+        }
+    });
+
+    function delve(the_function) {
+        Object.keys(the_function.context).forEach(function (id) {
+            if (id !== "ignore") {
+                const name = the_function.context[id];
+                if (name.function === the_function) {
+                    if (
+                        name.used === 0 && (
+                            name.role !== "function"
+                            || name.function.arity !== "unary"
+                        )
+                    ) {
+                        warn("unused_a", name);
+                    } else if (!name.init) {
+                        warn("uninitialized_a", name);
+                    }
+                }
+            }
+        });
+    }
+
+    function uninitialized_and_unused() {
+
+// Delve into the functions looking for variables that were not initialized
+// or used. If the file imports or exports, then its global object is also
+// delved.
+
+        if (module_mode === true || option.node) {
+            delve(global);
+        }
+        functions.forEach(delve);
+    }
+
+// Go through the token list, looking at usage of whitespace.
+
+    function whitage() {
+        let closer = "(end)";
+        let free = false;
+        let left = global;
+        let margin = 0;
+        let nr_comments_skipped = 0;
+        let open = true;
+        let qmark = "";
+        let result;
+        let right;
+
+        function expected_at(at) {
+            warn(
+                "expected_a_at_b_c",
+                right,
+                artifact(right),
+                fudge + at,
+                artifact_column(right)
+            );
+        }
+
+        function at_margin(fit) {
+            const at = margin + fit;
+            if (right.from !== at) {
+                return expected_at(at);
+            }
+        }
+
+        function no_space_only() {
+            if (
+                left.id !== "(global)"
+                && left.nr + 1 === right.nr
+                && (
+                    left.line !== right.line
+                    || left.thru !== right.from
+                )
+            ) {
+                warn(
+                    "unexpected_space_a_b",
+                    right,
+                    artifact(left),
+                    artifact(right)
+                );
+            }
+        }
+
+        function no_space() {
+            if (left.line === right.line) {
+                if (left.thru !== right.from && nr_comments_skipped === 0) {
+                    warn(
+                        "unexpected_space_a_b",
+                        right,
+                        artifact(left),
+                        artifact(right)
+                    );
+                }
+            } else {
+                if (open) {
+                    const at = (free)
+                        ? margin
+                        : margin + 8;
+                    if (right.from < at) {
+                        expected_at(at);
+                    }
+                } else {
+                    if (right.from !== margin + 8) {
+                        expected_at(margin + 8);
+                    }
+                }
+            }
+        }
+
+        function one_space_only() {
+            if (left.line !== right.line || left.thru + 1 !== right.from) {
+                warn(
+                    "expected_space_a_b",
+                    right,
+                    artifact(left),
+                    artifact(right)
+                );
+            }
+        }
+
+        function one_space() {
+            if (left.line === right.line) {
+                if (left.thru + 1 !== right.from && nr_comments_skipped === 0) {
+                    warn(
+                        "expected_space_a_b",
+                        right,
+                        artifact(left),
+                        artifact(right)
+                    );
+                }
+            } else {
+                if (free) {
+                    if (right.from < margin) {
+                        expected_at(margin);
+                    }
+                } else {
+                    const mislaid = (stack.length) > 0
+                        ? stack[stack.length - 1].right
+                        : undefined;
+                    if (!open && mislaid !== undefined) {
+                        warn(
+                            "expected_a_next_at_b",
+                            mislaid,
+                            artifact(mislaid.id),
+                            margin + 4 + fudge
+                        );
+                    } else if (right.from !== margin + 8) {
+                        expected_at(margin + 8);
+                    }
+                }
+            }
+        }
+
+        function unqmark() {
+
+// Undo the effects of dangling nested ternary operators.
+
+            const level = qmark.length;
+            if (level > 0) {
+                margin -= level * 4;
+            }
+            qmark = "";
+        }
+
+        stack = [];
+        tokens.forEach(function (the_token) {
+            right = the_token;
+            if (right.id === "(comment)" || right.id === "(end)") {
+                nr_comments_skipped += 1;
+            } else {
+
+// If left is an opener and right is not the closer, then push the previous
+// state. If the token following the opener is on the next line, then this is
+// an open form. If the tokens are on the same line, then it is a closed form.
+// Open form is more readable, with each item (statement, argument, parameter,
+// etc) starting on its own line. Closed form is more compact. Statement blocks
+// are always in open form.
+
+                const new_closer = opener[left.id];
+                if (typeof new_closer === "string") {
+                    if (new_closer !== right.id) {
+                        stack.push({
+                            closer: closer,
+                            free: free,
+                            margin: margin,
+                            open: open,
+                            qmark: qmark,
+                            right: right
+                        });
+                        qmark = "";
+                        closer = new_closer;
+                        if (left.line !== right.line) {
+                            free = closer === ")" && left.free;
+                            open = true;
+                            margin += 4;
+                            if (right.role === "label") {
+                                if (right.from !== 0) {
+                                    expected_at(0);
+                                }
+                            } else if (right.switch) {
+                                unqmark();
+                                at_margin(-4);
+                            } else {
+                                at_margin(0);
+                            }
+                        } else {
+                            if (right.statement || right.role === "label") {
+                                warn(
+                                    "expected_line_break_a_b",
+                                    right,
+                                    artifact(left),
+                                    artifact(right)
+                                );
+                            }
+                            free = false;
+                            open = false;
+                            no_space_only();
+                        }
+                    } else {
+
+// If left and right are opener and closer, then the placement of right depends
+// on the openness. Illegal pairs (like {]) have already been detected.
+
+                        if (left.line === right.line) {
+                            no_space();
+                        } else {
+                            at_margin(0);
+                        }
+                    }
+                } else {
+
+// If right is a closer, then pop the previous state.
+
+                    if (right.id === closer) {
+                        const previous = stack.pop();
+                        margin = previous.margin;
+                        if (open && right.id !== ";") {
+                            at_margin(0);
+                        } else {
+                            no_space_only();
+                        }
+                        closer = previous.closer;
+                        free = previous.free;
+                        open = previous.open;
+                        qmark = previous.qmark;
+                    } else {
+
+// Left is not an opener, and right is not a closer. The nature of left and
+// right will determine the space between them.
+
+// If left is , or ; or right is a statement then if open, right must go at the
+// margin, or if closed, a space between.
+
+
+                        if (right.switch) {
+                            unqmark();
+                            at_margin(-4);
+                        } else if (right.role === "label") {
+                            if (right.from !== 0) {
+                                expected_at(0);
+                            }
+                        } else if (left.id === ",") {
+                            unqmark();
+                            if (!open || (
+                                (free || closer === "]")
+                                && left.line === right.line
+                            )) {
+                                one_space();
+                            } else {
+                                at_margin(0);
+                            }
+
+// If right is a ternary operator, line it up on the margin. Use qmark to
+// deal with nested ternary operators.
+
+                        } else if (right.arity === "ternary") {
+                            if (right.id === "?") {
+                                margin += 4;
+                                qmark += "?";
+                            } else {
+                                result = qmark.match(rx_colons);
+                                qmark = result[1] + ":";
+                                margin -= 4 * result[2].length;
+                            }
+                            at_margin(0);
+                        } else if (
+                            right.arity === "binary"
+                            && right.id === "("
+                            && free
+                        ) {
+                            no_space();
+                        } else if (
+                            left.id === "."
+                            || left.id === "..."
+                            || right.id === ","
+                            || right.id === ";"
+                            || right.id === ":"
+                            || (
+                                right.arity === "binary"
+                                && (right.id === "(" || right.id === "[")
+                            )
+                            || (
+                                right.arity === "function"
+                                && left.id !== "function"
+                            )
+                        ) {
+                            no_space_only();
+                        } else if (right.id === ".") {
+                            if (left.line === right.line) {
+                                no_space();
+                            } else {
+                                if (!rx_dot.test(qmark)) {
+                                    qmark += ".";
+                                    margin += 4;
+                                }
+                                at_margin(0);
+                            }
+                        } else if (left.id === ";") {
+                            unqmark();
+                            if (open) {
+                                at_margin(0);
+                            } else {
+                                one_space();
+                            }
+                        } else if (
+                            left.arity === "ternary"
+                            || left.id === "case"
+                            || left.id === "catch"
+                            || left.id === "else"
+                            || left.id === "finally"
+                            || left.id === "while"
+                            || right.id === "catch"
+                            || right.id === "else"
+                            || right.id === "finally"
+                            || (right.id === "while" && !right.statement)
+                            || (left.id === ")" && right.id === "{")
+                        ) {
+                            one_space_only();
+                        } else if (right.statement === true) {
+                            if (open) {
+                                at_margin(0);
+                            } else {
+                                one_space();
+                            }
+                        } else if (
+                            left.id === "var"
+                            || left.id === "const"
+                            || left.id === "let"
+                        ) {
+                            stack.push({
+                                closer: closer,
+                                free: free,
+                                margin: margin,
+                                open: open,
+                                qmark: qmark
+                            });
+                            closer = ";";
+                            free = false;
+                            open = left.open;
+                            qmark = "";
+                            if (open) {
+                                margin = margin + 4;
+                                at_margin(0);
+                            } else {
+                                one_space_only();
+                            }
+                        } else if (
+
+// There is a space between left and right.
+
+                            spaceop[left.id] === true
+                            || spaceop[right.id] === true
+                            || (
+                                left.arity === "binary"
+                                && (left.id === "+" || left.id === "-")
+                            )
+                            || (
+                                right.arity === "binary"
+                                && (right.id === "+" || right.id === "-")
+                            )
+                            || left.id === "function"
+                            || left.id === ":"
+                            || (
+                                (
+                                    left.identifier
+                                    || left.id === "(string)"
+                                    || left.id === "(number)"
+                                )
+                                && (
+                                    right.identifier
+                                    || right.id === "(string)"
+                                    || right.id === "(number)"
+                                )
+                            )
+                            || (left.arity === "statement" && right.id !== ";")
+                        ) {
+                            one_space();
+                        } else if (left.arity === "unary" && left.id !== "`") {
+                            no_space_only();
+                        }
+                    }
+                }
+                nr_comments_skipped = 0;
+                delete left.calls;
+                delete left.dead;
+                delete left.free;
+                delete left.init;
+                delete left.open;
+                delete left.used;
+                left = right;
+            }
+        });
+    }
+
+// The jslint function itself.
+
+    return function jslint(source, option_object, global_array) {
+        try {
+            warnings = [];
+            option = Object.assign(empty(), option_object);
+            anon = "anonymous";
+            block_stack = [];
+            declared_globals = empty();
+            directive_mode = true;
+            directives = [];
+            early_stop = true;
+            exports = empty();
+            froms = [];
+            fudge = (option.fudge)
+                ? 1
+                : 0;
+            functions = [];
+            global = {
+                id: "(global)",
+                body: true,
+                context: empty(),
+                from: 0,
+                level: 0,
+                line: 0,
+                live: [],
+                loop: 0,
+                switch: 0,
+                thru: 0
+            };
+            blockage = global;
+            functionage = global;
+            json_mode = false;
+            mega_mode = false;
+            module_mode = false;
+            next_token = global;
+            property = empty();
+            stack = [];
+            tenure = undefined;
+            token = global;
+            token_nr = 0;
+            var_mode = undefined;
+            populate(declared_globals, standard, false);
+            //populate(declared_globals, useable_standard, false);
+            if (global_array !== undefined) {
+                populate(declared_globals, global_array, false);
+            }
+            Object.keys(option).forEach(function (name) {
+                if (option[name] === true) {
+                    const allowed = allowed_option[name];
+                    if (Array.isArray(allowed)) {
+                        populate(declared_globals, allowed, false);
+                    }
+                }
+            });
+            tokenize(source);
+            advance();
+            if (json_mode) {
+                tree = json_value();
+                advance("(end)");
+            } else {
+
+// Because browsers encourage combining of script files, the first token might
+// be a semicolon to defend against a missing semicolon in the preceding file.
+
+                if (option.browser) {
+                    if (next_token.id === ";") {
+                        advance(";");
+                    }
+                } else {
+
+// If we are not in a browser, then the file form of strict pragma may be used.
+
+                    if (
+                        next_token.value === "use strict"
+                    ) {
+                        global.strict = next_token;
+                        advance("(string)");
+                        advance(";");
+                    }
+                }
+                tree = statements();
+                advance("(end)");
+                functionage = global;
+                walk_statement(tree);
+                if (module_mode && global.strict !== undefined) {
+                    warn("unexpected_a", global.strict);
+                }
+                uninitialized_and_unused();
+                if (!option.white) {
+                    whitage();
+                }
+            }
+            if (!option.browser) {
+                directives.forEach(function (comment) {
+                    if (comment.directive === "global") {
+                        warn("missing_browser", comment);
+                    }
+                });
+            }
+            early_stop = false;
+        } catch (e) {
+            if (e.name !== "JSLintError") {
+                warnings.push(e);
+            }
+        }
+        return {
+            directives: directives,
+            edition: "2018-01-04",
+            exports: exports,
+            froms: froms,
+            functions: functions,
+            global: global,
+            id: "(JSLint)",
+            json: json_mode,
+            lines: lines,
+            module: module_mode === true,
+            ok: warnings.length === 0 && !early_stop,
+            option: option,
+            property: property,
+            stop: early_stop,
+            tokens: tokens,
+            tree: tree,
+            warnings: warnings.sort(function (a, b) {
+                return a.line - b.line || a.column - b.column;
+            })
+        };
+    };
+}());
+
+
+//call js lint by user. 2018-01-19
+function callJslint(js_value, global_string) {
+	var option_array = Object.create(null);
+	option_array["single"] = true;
+	option_array["white"] = true;
+	var rx_separator = /[\s,;'"]+/;
+	var pre_defined = (global_string === "") ? undefined : global_string.split(rx_separator);
+	var data = jslint(js_value, option_array, pre_defined); 
+
+	return JSON.stringify(data.warnings);
+}
\ No newline at end of file
diff --git a/samples/shell.cc b/samples/shell.cc
index e042815..f43d6f3 100644
--- a/samples/shell.cc
+++ b/samples/shell.cc
@@ -35,6 +35,64 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include <map>
+#include <utility>
+#include <utility>      // std::pair
+#include <iostream>     // std::cout
+#include<stdio.h>
+#include <time.h> 
+#include <stdio.h> 
+#include <cstdio>
+
+#ifdef WIN32
+#include "Windows.h"
+#define FOREGROUND_BLUE      0x0001 // text color contains blue.
+#define FOREGROUND_GREEN     0x0002 // text color contains green.
+#define FOREGROUND_RED       0x0004 // text color contains red.
+#define FOREGROUND_INTENSITY 0x0008 // text color is intensified.
+#define BACKGROUND_BLUE      0x0010 // background color contains blue.
+#define BACKGROUND_GREEN     0x0020 // background color contains green.
+#define BACKGROUND_RED       0x0040 // background color contains red.
+#define BACKGROUND_INTENSITY 0x0080 // background color is intensified.
+#else
+#include <unistd.h>
+#endif
+
+#define RUN_UTEST
+#define USE_MEM_MONITOR
+#define USE_CHECK_TIME
+#define USE_NEW_IOSLATE
+
+#ifdef USE_CHECK_TIME
+char check_time[100] = "__enable_check_time__";
+#else
+char check_time[100] = { 0 };
+#endif
+
+int g_repetition_count = 10000;
+unsigned int g_check_block_time_count = 0;
+unsigned int g_check_all_time_count = 0;
+
+#if 0
+#define LOG_INFO printf
+#else
+void shell_no_printf(const char* format, ...) {}
+#define LOG_INFO shell_no_printf
+#endif
+
+std::map<std::string, std::string> file_script_map_;
+
+static int64_t Stoi64(const std::string &str)
+{
+	int64_t v = 0;
+#ifdef WIN32
+	sscanf_s(str.c_str(), "%lld", &v);
+#else
+	sscanf(str.c_str(), "%ld", &v);
+#endif
+	return v;
+}
+
 /**
  * This sample program shows how to implement a simple javascript shell
  * based on V8.  This includes initializing V8 with command line options,
@@ -46,54 +104,155 @@
 
 v8::Local<v8::Context> CreateShellContext(v8::Isolate* isolate);
 void RunShell(v8::Local<v8::Context> context, v8::Platform* platform);
+void RunUtest(v8::Local<v8::Context> context, v8::Platform* platform);
 int RunMain(v8::Isolate* isolate, v8::Platform* platform, int argc,
             char* argv[]);
 bool ExecuteString(v8::Isolate* isolate, v8::Local<v8::String> source,
                    v8::Local<v8::Value> name, bool print_result,
                    bool report_exceptions);
 void Print(const v8::FunctionCallbackInfo<v8::Value>& args);
+void CheckTime(const v8::FunctionCallbackInfo<v8::Value>& args);
+void Add(const v8::FunctionCallbackInfo<v8::Value>& args);
+void Include(const v8::FunctionCallbackInfo<v8::Value>& args);
 void Read(const v8::FunctionCallbackInfo<v8::Value>& args);
 void Load(const v8::FunctionCallbackInfo<v8::Value>& args);
 void Quit(const v8::FunctionCallbackInfo<v8::Value>& args);
 void Version(const v8::FunctionCallbackInfo<v8::Value>& args);
 v8::MaybeLocal<v8::String> ReadFile(v8::Isolate* isolate, const char* name);
 void ReportException(v8::Isolate* isolate, v8::TryCatch* handler);
+static const char* last_location;
+static const char* last_message;
+void StoringErrorCallback(const char* location, const char* message) {
+	if (last_location == NULL) {
+		last_location = location;
+		last_message = message;
+	}
+	printf("location:%s, message:%s\n", location, message);
+}
 
 
 static bool run_shell;
 
-
-int main(int argc, char* argv[]) {
-  v8::V8::InitializeICUDefaultLocation(argv[0]);
-  v8::V8::InitializeExternalStartupData(argv[0]);
-  v8::Platform* platform = v8::platform::CreateDefaultPlatform();
-  v8::V8::InitializePlatform(platform);
-  v8::V8::Initialize();
-  v8::V8::SetFlagsFromCommandLine(&argc, argv, true);
-  v8::Isolate::CreateParams create_params;
-  create_params.array_buffer_allocator =
-      v8::ArrayBuffer::Allocator::NewDefaultAllocator();
-  v8::Isolate* isolate = v8::Isolate::New(create_params);
-  run_shell = (argc == 1);
-  int result;
-  {
-    v8::Isolate::Scope isolate_scope(isolate);
-    v8::HandleScope handle_scope(isolate);
-    v8::Local<v8::Context> context = CreateShellContext(isolate);
-    if (context.IsEmpty()) {
-      fprintf(stderr, "Error creating context\n");
-      return 1;
-    }
-    v8::Context::Scope context_scope(context);
-    result = RunMain(isolate, platform, argc, argv);
-    if (run_shell) RunShell(context, platform);
-  }
-  isolate->Dispose();
-  v8::V8::Dispose();
-  v8::V8::ShutdownPlatform();
-  delete platform;
-  delete create_params.array_buffer_allocator;
-  return result;
+int Repetition(int argc, char* argv[])
+{
+	v8::V8::InitializeICUDefaultLocation(argv[0]);
+	v8::V8::InitializeExternalStartupData(argv[0]);
+	v8::Platform* platform = v8::platform::CreateDefaultPlatform();
+	v8::V8::InitializePlatform(platform);
+	v8::V8::Initialize();
+	v8::V8::SetFlagsFromCommandLine(&argc, argv, true);
+
+	time_t start_t = time(0);
+	char start_tmp[64];
+	strftime(start_tmp, sizeof(start_tmp), "%Y/%m/%d %X", localtime(&start_t));
+	printf("Utest start time:%s\n", start_tmp);
+	int result;
+	v8::Isolate::CreateParams create_params;
+	create_params.array_buffer_allocator =
+		v8::ArrayBuffer::Allocator::NewDefaultAllocator();
+	/*create_params.constraints.set_code_range_size(512);
+	create_params.constraints.set_max_executable_size(2 * 1024);
+	create_params.constraints.set_max_old_space_size(2 * 1024);
+	create_params.constraints.set_max_semi_space_size(512);*/
+#ifndef USE_NEW_IOSLATE
+	v8::Isolate* isolate = v8::Isolate::New(create_params);
+	isolate->SetFatalErrorHandler(StoringErrorCallback);
+#endif
+
+	last_location = last_message = NULL;
+	for (int i = 0; i < g_repetition_count; i++)
+	{
+#ifdef USE_NEW_IOSLATE
+		v8::Isolate* isolate = v8::Isolate::New(create_params);
+		isolate->SetFatalErrorHandler(StoringErrorCallback);
+#endif
+		{
+			v8::Isolate::Scope isolate_scope(isolate);
+			v8::HandleScope handle_scope(isolate);
+			v8::Local<v8::Context> context = CreateShellContext(isolate);
+			run_shell = (argc == 1);
+			{
+
+				if (context.IsEmpty()) {
+					fprintf(stderr, "Error creating context\n");
+					return 1;
+				}
+				v8::Context::Scope context_scope(context);
+				result = RunMain(isolate, platform, argc, argv);
+#ifdef RUN_UTEST
+				RunUtest(context, platform);
+#else
+				if (run_shell) RunShell(context, platform);
+#endif
+			}
+		}
+
+#ifdef USE_NEW_IOSLATE
+		isolate->Dispose();
+#endif
+	}
+
+	delete create_params.array_buffer_allocator;
+	time_t end_t = time(0);
+	char end_tmp[64];
+	strftime(end_tmp, sizeof(end_tmp), "%Y/%m/%d %X", localtime(&end_t));
+	printf("Utest end time:%s\n", end_tmp);
+
+	char buffer[10000];
+	char* str = fgets(buffer, 10000, stdin);
+#ifndef USE_NEW_IOSLATE
+	isolate->Dispose();
+#endif
+
+	v8::V8::Dispose();
+	v8::V8::ShutdownPlatform();
+	delete platform;
+
+	return result;
+}
+
+void ReadScriptFromFile(std::string file_name)
+{
+	FILE * stream = nullptr;
+	if (stream == nullptr)
+	{
+		printf("open file %s\n", file_name.c_str());
+		stream = fopen(file_name.data(), "rb");
+	}
+	if (stream == nullptr)
+	{
+		printf("cannot find %s\n", file_name.c_str());
+		return;
+	}
+	std::string str;
+	if (str.empty())
+	{
+		fseek(stream, 0, SEEK_END);
+		size_t len = ftell(stream);
+		char *buffer = new char[len + 1];
+		memset(buffer, 0, len + 1);
+		fseek(stream, 0, SEEK_SET);
+		fread(buffer, len, 1, stream);
+		std::string str_temp(buffer, len);
+		str = str_temp;
+	}
+
+	fclose(stream);
+
+	file_script_map_[file_name] = str;
+}
+
+int main(int argc, char* argv[])
+{
+	ReadScriptFromFile("adsafe_dep.js");
+	ReadScriptFromFile("big.js");
+	ReadScriptFromFile("adsafe.js");
+	ReadScriptFromFile("jslint.js");
+	ReadScriptFromFile("test.js");
+	Repetition(argc, argv);
+	printf("print any key to exit:\n");
+	getchar();
+	return 0;
 }
 
 
@@ -113,6 +272,24 @@ v8::Local<v8::Context> CreateShellContext(v8::Isolate* isolate) {
       v8::String::NewFromUtf8(isolate, "print", v8::NewStringType::kNormal)
           .ToLocalChecked(),
       v8::FunctionTemplate::New(isolate, Print));
+
+  // Bind the global 'check_time' function to the C++ CheckTime callback.
+  global->Set(
+	  v8::String::NewFromUtf8(isolate, "internal_check_time", v8::NewStringType::kNormal)
+	  .ToLocalChecked(),
+	  v8::FunctionTemplate::New(isolate, CheckTime));
+
+  // Bind the global 'check_time' function to the C++ Add callback.
+  global->Set(
+	  v8::String::NewFromUtf8(isolate, "internal_add", v8::NewStringType::kNormal)
+	  .ToLocalChecked(),
+	  v8::FunctionTemplate::New(isolate, Add));
+
+  global->Set(
+	  v8::String::NewFromUtf8(isolate, "include", v8::NewStringType::kNormal)
+	  .ToLocalChecked(),
+	  v8::FunctionTemplate::New(isolate, Include));
+
   // Bind the global 'read' function to the C++ Read callback.
   global->Set(v8::String::NewFromUtf8(
                   isolate, "read", v8::NewStringType::kNormal).ToLocalChecked(),
@@ -139,6 +316,9 @@ v8::Local<v8::Context> CreateShellContext(v8::Isolate* isolate) {
 // function is called.  Prints its arguments on stdout separated by
 // spaces and ending with a newline.
 void Print(const v8::FunctionCallbackInfo<v8::Value>& args) {
+#ifdef RUN_UTEST
+	return;
+#endif
   bool first = true;
   for (int i = 0; i < args.Length(); i++) {
     v8::HandleScope handle_scope(args.GetIsolate());
@@ -147,6 +327,16 @@ void Print(const v8::FunctionCallbackInfo<v8::Value>& args) {
     } else {
       printf(" ");
     }
+
+
+	{
+		if (args[i]->IsObject()) {  //include map arrary
+			v8::Local<v8::String> jsStr = v8::JSON::Stringify(args.GetIsolate()->GetCurrentContext(), args[i]->ToObject()).ToLocalChecked();
+			std::string str = std::string(ToCString(v8::String::Utf8Value(jsStr)));
+			LOG_INFO("%s\n", str.c_str());
+		}
+	}
+
     v8::String::Utf8Value str(args[i]);
     const char* cstr = ToCString(str);
     printf("%s", cstr);
@@ -155,6 +345,100 @@ void Print(const v8::FunctionCallbackInfo<v8::Value>& args) {
   fflush(stdout);
 }
 
+// The callback that is invoked by v8 whenever the JavaScript 'print'
+// function is called.  Prints its arguments on stdout separated by
+// spaces and ending with a newline.
+void CheckTime(const v8::FunctionCallbackInfo<v8::Value>& args) {
+#ifndef RUN_UTEST
+	LOG_INFO("internal_check_time:%d, block:%d\n", g_check_all_time_count, g_check_block_time_count);
+#endif
+	if (g_check_all_time_count % 100000 == 0)
+	{
+		//printf("%d\n", g_check_all_time_count);
+		v8::HeapStatistics stats;
+		args.GetIsolate()->GetHeapStatistics(&stats);
+		//printf("limite:%u, used:%u\n", (unsigned int)stats.heap_size_limit(), (unsigned int)stats.used_heap_size());
+	}
+	v8::String::Utf8Value is_first_org(args[0]);
+	std::string is_first_src = *is_first_org;
+	bool is_first = (is_first_src.compare("true") == 0) ? true : false;
+	if (is_first)
+	{
+		g_check_block_time_count++;
+	}
+	g_check_all_time_count++;
+#ifdef USE_MEM_MONITOR
+	v8::HeapStatistics stats;
+	args.GetIsolate()->GetHeapStatistics(&stats);
+	/*  printf("%u,%u,%u,%u,%u,%u,%u,%u,%u\n", stats.does_zap_garbage(), stats.heap_size_limit(), stats.malloced_memory(), stats.peak_malloced_memory(), stats.total_available_size(),
+	stats.total_heap_size(), stats.total_heap_size_executable(), stats.total_physical_size(), stats.used_heap_size());*/
+	LOG_INFO("limite:%u, used:%u\n", (unsigned int)stats.heap_size_limit(), (unsigned int)stats.used_heap_size());
+	//printf("context->EstimatedSize:%d\n", context->EstimatedSize());
+	v8::V8InternalInfo internal_info;
+	args.GetIsolate()->GetV8InternalInfo(internal_info);
+	LOG_INFO("v8 max_stack_size:%d, remain:%d\n", internal_info.max_stack_size, internal_info.remain_stack_size);
+
+#endif
+
+	return;
+}
+
+void Add(const v8::FunctionCallbackInfo<v8::Value>& args)
+{
+	if (args.Length() != 2)
+	{
+		args.GetIsolate()->ThrowException(
+			v8::String::NewFromUtf8(args.GetIsolate(), "Bad parameters",
+				v8::NewStringType::kNormal).ToLocalChecked());
+		return;
+	}
+
+	char add_result[100] = { 0 };
+
+	v8::String::Utf8Value add_1(args[0]);
+	v8::String::Utf8Value add_2(args[1]);
+
+	int64_t add_int64_result = Stoi64(*add_1) + Stoi64(*add_2);
+#ifdef WIN32
+	sprintf(add_result, "%lld", add_int64_result);
+#else
+	sprintf(add_result, "%ld", add_int64_result);
+#endif
+
+	v8::Local<v8::String> result(v8::String::NewFromUtf8(args.GetIsolate(), add_result, v8::NewStringType::kNormal).ToLocalChecked());
+	args.GetReturnValue().Set(result);
+	return;
+}
+
+void Include(const v8::FunctionCallbackInfo<v8::Value>& args)
+{
+	v8::Local<v8::Context> context = args.GetIsolate()->GetCurrentContext();
+	// Enter the execution environment before evaluating any code.
+	v8::Context::Scope context_scope(context);
+
+	if (args.Length() != 1) {
+		LOG_INFO("Include parameter error, args length(%d) not equal 1\n", args.Length());
+		args.GetReturnValue().Set(false);
+		return;
+	}
+
+	if (!args[0]->IsString()) {
+		LOG_INFO("Include parameter error, parameter should be a String\n");
+		args.GetReturnValue().Set(false);
+		return;
+	}
+	v8::String::Utf8Value str(args[0]);
+	std::map<std::string, std::string>::iterator find_source = file_script_map_.find(*str);
+	if (find_source == file_script_map_.end()) {
+		LOG_INFO("Can't find the include file(%s) in jslib directory\n", *str);
+		args.GetReturnValue().Set(false);
+		return;
+	}
+	std::string js_file = find_source->second;
+
+	v8::Local<v8::String> name(v8::String::NewFromUtf8(context->GetIsolate(), check_time, v8::NewStringType::kNormal).ToLocalChecked());
+	ExecuteString(context->GetIsolate(), v8::String::NewFromUtf8(context->GetIsolate(), js_file.data(), v8::NewStringType::kNormal).ToLocalChecked(), name, true, true);
+}
 
 // The callback that is invoked by v8 whenever the JavaScript 'read'
 // function is called.  This function loads the content of the file named in
@@ -310,17 +594,19 @@ int RunMain(v8::Isolate* isolate, v8::Platform* platform, int argc,
 // The read-eval-execute loop of the shell.
 void RunShell(v8::Local<v8::Context> context, v8::Platform* platform) {
   fprintf(stderr, "V8 version %s [sample shell]\n", v8::V8::GetVersion());
-  static const int kBufferSize = 256;
+  static const int kBufferSize = 10 * 1000;
   // Enter the execution environment before evaluating any code.
   v8::Context::Scope context_scope(context);
   v8::Local<v8::String> name(
-      v8::String::NewFromUtf8(context->GetIsolate(), "(shell)",
+      v8::String::NewFromUtf8(context->GetIsolate(), check_time,
                               v8::NewStringType::kNormal).ToLocalChecked());
   while (true) {
     char buffer[kBufferSize];
     fprintf(stderr, "> ");
     char* str = fgets(buffer, kBufferSize, stdin);
     if (str == NULL) break;
+	std::string str_target(str);
+	if (str_target.compare("exit\n") == 0) break;
     v8::HandleScope handle_scope(context->GetIsolate());
     ExecuteString(
         context->GetIsolate(),
@@ -333,6 +619,111 @@ void RunShell(v8::Local<v8::Context> context, v8::Platform* platform) {
   fprintf(stderr, "\n");
 }
 
+void RunUtest(v8::Local<v8::Context> context, v8::Platform* platform)
+{
+	typedef struct tagSplitCase
+	{
+		int expect_block_result;
+		int expect_all_result;
+		std::string str;
+	}SplitCase;
+	static std::vector<SplitCase> split_cases;
+
+	if (split_cases.empty())
+	{
+		std::string file_name = "v8-utest.txt";
+		static FILE * stream = fopen(file_name.data(), "r");
+
+		if (stream == nullptr)
+		{
+			printf("cannot find v8-utest.txt\n");
+			return;
+		}
+		fseek(stream, 0, SEEK_SET);
+
+		std::vector<std::string> script_vector;
+		char line[10000];
+		while (fgets(line, 10000, stream) != NULL)
+		{
+			//printf("line:%s\n", line);
+			script_vector.push_back(line);
+		}
+
+		for (unsigned int i = 0; i < script_vector.size(); i++)
+		{
+			std::string scrpit_all = script_vector[i];
+			size_t idx = scrpit_all.find(',');
+			if (idx == std::string::npos)
+			{
+				printf("error script [index:%d] :%s", i + 1, scrpit_all.c_str());
+				continue;
+			}
+			SplitCase one_case;
+			one_case.expect_block_result = atoi(scrpit_all.substr(0, idx).data());
+			size_t idx_2 = scrpit_all.find(',', idx + 1);
+			if (idx_2 == std::string::npos)
+			{
+				printf("error script [index:%d] :%s", i + 1, scrpit_all.c_str());
+				continue;
+			}
+			one_case.expect_all_result = atoi(scrpit_all.substr(idx + 1, idx_2 + 1).data());
+			one_case.str = scrpit_all.substr(idx_2 + 1, std::string::npos);
+			split_cases.push_back(one_case);
+		}
+	}
+
+	LOG_INFO("-----------------------Utest Start------------------------------------------------\n");
+	static const int kBufferSize = 10 * 1024;
+	// Enter the execution environment before evaluating any code.
+	for (unsigned int i = 0; i < split_cases.size(); i++)
+	{
+		const SplitCase &one_case = split_cases[i];
+		int expect_block_result = one_case.expect_block_result;
+		int expect_all_result = one_case.expect_all_result;
+		std::string script_src = one_case.str;
+
+		v8::Context::Scope context_scope(context);
+		v8::Local<v8::String> name(
+			v8::String::NewFromUtf8(context->GetIsolate(), check_time,
+				v8::NewStringType::kNormal).ToLocalChecked());
+
+		char buffer[kBufferSize];
+		//fprintf(stderr, "> ");
+		v8::HandleScope handle_scope(context->GetIsolate());
+		ExecuteString(
+			context->GetIsolate(),
+			v8::String::NewFromUtf8(context->GetIsolate(), script_src.data(),
+				v8::NewStringType::kNormal).ToLocalChecked(),
+			name, true, true);
+
+		if ((g_check_block_time_count == (unsigned int)expect_block_result)
+			&& (g_check_all_time_count == (unsigned int)expect_all_result))
+		{
+			LOG_INFO("-----------------------Utest [%d] OK.[expect,true] [%d,%u] [%d, %u]----------------------\n",
+				i + 1, expect_block_result, g_check_block_time_count, expect_all_result, g_check_all_time_count);
+		}
+		else
+		{
+#ifdef WIN32
+			HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);
+#endif
+			LOG_INFO("-----------------------Src: %s\n", script_src.c_str());
+			LOG_INFO("-----------------------Utest [%d] ERR.[expect,true] [%d,%u] [%d, %u]----------------------\n",
+				i + 1, expect_block_result, g_check_block_time_count, expect_all_result, g_check_all_time_count);
+			g_check_block_time_count = 0;
+			g_check_all_time_count = 0;
+			break;
+		}
+		//assert(g_check_block_time_count == expect_result);
+
+		g_check_block_time_count = 0;
+		g_check_all_time_count = 0;
+	}
+
+	LOG_INFO("\n-----------------------Utest End------------------------------------------------\n");
+}
+
 
 // Executes a string within the current v8 context.
 bool ExecuteString(v8::Isolate* isolate, v8::Local<v8::String> source,
@@ -363,10 +754,16 @@ bool ExecuteString(v8::Isolate* isolate, v8::Local<v8::String> source,
         // the returned value.
         v8::String::Utf8Value str(result);
         const char* cstr = ToCString(str);
-        printf("%s\n", cstr);
+        //printf("%s\n", cstr);
       }
       return true;
     }
+	v8::HeapStatistics stats;
+	isolate->GetHeapStatistics(&stats);
+	/*  printf("%u,%u,%u,%u,%u,%u,%u,%u,%u\n", stats.does_zap_garbage(), stats.heap_size_limit(), stats.malloced_memory(), stats.peak_malloced_memory(), stats.total_available_size(),
+	stats.total_heap_size(), stats.total_heap_size_executable(), stats.total_physical_size(), stats.used_heap_size());*/
+	//printf("limit:%u, used:%u\n", stats.heap_size_limit(), stats.used_heap_size());
+	//printf("context->EstimatedSize:%d\n", context->EstimatedSize());
   }
 }
 
diff --git a/samples/test.js b/samples/test.js
new file mode 100644
index 0000000..982ca19
--- /dev/null
+++ b/samples/test.js
@@ -0,0 +1,6540 @@
+function hello() {
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+	 print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a"); print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+    print("a");
+}
\ No newline at end of file
diff --git a/samples/v8-utest.txt b/samples/v8-utest.txt
new file mode 100644
index 0000000..3cc9b3b
--- /dev/null
+++ b/samples/v8-utest.txt
@@ -0,0 +1,34 @@
+1,3,var a = 4; var b = a ; print(a);
+2,2,try{print("try")}catch(error){print("catch")}
+3,9,function Lakers(){this.name="kobe bryant";this.age="28";this.gender="boy"}var people=new Lakers();with(people){var str="name: "+name+"<br>";str+="age："+age+"<br>";str+="sex："+gender;print(str)}
+4,8,try{print("try");print("try")}catch(error){print("catch");print("catch");print("catch")}finally{print("finally ");print("finally ");print("finally ");print("finally ")}
+4,4,try{print("try")}catch(error){print("catch")}finally{print("finally ")}
+5,10,var arryAll=[];arryAll.push(1);arryAll.push(2);arryAll.push(3);arryAll.push(4);function t1(arg){print(arg)}arryAll.forEach(t1,arryAll);
+13,23,var uniqueWords=new Set("abcd");for(var word of uniqueWords){print(word)}
+4,9,var a={"first":1,"second":2,"third":3};for(var i in a){print(a[i])}print("aaa");
+4,7,var i=1;do{if(i<=0){break}i--;print("a")}while(true);
+2,6,for(var i=1;i<=1;i++){print("a");print("b");print("c")}print("aaa");print("bbb")
+6,7,for(var i=1;i<=5;i++){print("a")}print("aaa");
+2,4,if(0){print("a");print("b");print("c")}else{print("c");print("b");print("a")}
+6,7,var i=1;while(i<=5){i++}
+6,17,var i=1;do{print("a");print("b");i++}while(i<=5)
+2,5,var i=2;switch(i){case 0:{print("0");print("0");print("0");break}case 1:{print("1");print("1");print("1");break}default:{print("d");print("d");print("d");break}}
+7,17,var i=1;while(i<=5){if(i==3){i++;continue};print("a");i++}
+4,9,var i=1;while(i<=5){if(i==3)break;print("a");i++}
+4,11,var i=1;var a=i;while(i<=5){if(i==3)break;print("a");i++}var b=i;
+3,5,function FunA(){var a=2;var b=3;var c=a}function FunB(){FunA()}FunB();
+6,20,function FunC(){var a=4;var b=a;print(a);for(var i=1;i<=1;i++){print("a");print("b");print("c")}print("aaa");print("bbb")}function FunA(){var a=2;var b=3;var c=a;FunC();var i=0;switch(i){case 0:{print("0");print("0");print("0");break}case 1:{print("1");print("1");print("1");break}default:{print("d");print("d");print("d");break}}}function FunB(){FunA()}FunB();
+102,302,var count_times=1;function FunB(){count_times++;if(count_times>100){return}return FunB()}FunB();
+5,9,function Biology(age){this.age=age};Biology.prototype={constructor:Biology,name:'biology',printAll:function(){print("printA")}};var biology_1=new Biology(16);var biology_2=new Biology(18);biology_1.printAll();biology_2.printAll();
+1,3,var Biology_1={};var Biology_2=new Object();var Biology_3=Object.create(null);
+5,15,function Biology(name){var tempObj=new Object();tempObj.name=name;tempObj.printName=function(){print(this.name)};return tempObj}var animals=Biology('animals');var plants=Biology('plants');animals.printName();plants.printName();animals.constructor;
+7,19,function Biology(){};Biology.prototype.name='biology';Biology.prototype.printName=function(){print(this.name)};var animals=new Biology();animals.printName();var plants=new Biology();plants.printName();print(animals.name);animals.name='animals';print(animals.name);print(plants.name);animals.printName=function(){print('animals')};animals.printName();plants.printName();
+2,5,function Biology(){};Biology.prototype={name:'biology',printName:function(){console.log(this.name)}};var biology=new Biology();print(biology.name);print(biology.constructor);
+2,4,function Biology(){};var biology=new Biology();Biology.prototype={constructor:Biology,name:'biology',printName:function(){console.log(this.name)}};print(biology.name);
+5,9,function Biology(age){this.age=age};Biology.prototype={constructor:Biology,name:'biology',printAll:function(){print(this.name+':'+this.age)}};var biology_1=new Biology(16);var biology_2=new Biology(18);biology_1.printAll();biology_2.printAll();
+11,41,function Biology(){function privateMethod(){return'私有方法'}var privateProperty='私有属性';this.publicProperty='实例属性';Biology.prototype.staticProperty='原型属性';var privateMethod=function(){return'私有方法'};this.publicMethod=function(){return'实例方法'};Biology.prototype.staticMethod=function(){return'原型方法'};this.getPrivateProperty=function(){return privateProperty};this.setPrivateProperty=function(property){privateProperty=property};this.getPrivateMethod=function(){return privateMethod()}}var biology=new Biology();var biology_2=new Biology();biology.publicProperty='修改后的实例属性';biology.setPrivateProperty('改变后的私有属性');print(biology.getPrivateProperty());Biology.prototype.staticProperty='修改后的原型属性';print(biology.staticProperty);print(biology_2.staticProperty);print(biology.privateMethod);print(biology.publicMethod());print(biology.getPrivateMethod());print(biology.staticMethod());Biology.prototype.staticMethod=function(){return'修改后的原型方法'};print(biology.staticMethod());print(biology_2.staticMethod());
+5,9,function Biology(age){this.age=age};Biology.prototype={constructor:Biology,name:'biology',printAll:function(){print(this.name+':'+this.age)}};var biology_1=new Biology(16);var biology_2=new Biology(18);biology_1.printAll();biology_2.printAll();
+11,41,function Biology(){function privateMethod(){return'私有方法'}var privateProperty='私有属性';this.publicProperty='实例属性';Biology.prototype.staticProperty='原型属性';var privateMethod=function(){return'私有方法'};this.publicMethod=function(){return'实例方法'};Biology.prototype.staticMethod=function(){return'原型方法'};this.getPrivateProperty=function(){return privateProperty};this.setPrivateProperty=function(property){privateProperty=property};this.getPrivateMethod=function(){return privateMethod()}}var biology=new Biology();var biology_2=new Biology();biology.publicProperty='修改后的实例属性';biology.setPrivateProperty('改变后的私有属性');print(biology.getPrivateProperty());Biology.prototype.staticProperty='修改后的原型属性';print(biology.staticProperty);print(biology_2.staticProperty);print(biology.privateMethod);print(biology.publicMethod());print(biology.getPrivateMethod());print(biology.staticMethod());Biology.prototype.staticMethod=function(){return'修改后的原型方法'};print(biology.staticMethod());print(biology_2.staticMethod());
+14,48,include("big.js"); x = new Big('18446744073709551615'); print(x);
+791,2397,include("jslint.js"); var js_value = "pridfdsafnt(dfadfa);"; var pre_defined = undefined;  var option = Object.create(null); var data=jslint(js_value, option, pre_defined); print("----------result-----------"); var last=JSON.stringify(data); print(last);
+3,6562,include("test.js"); hello();
\ No newline at end of file
diff --git "a/samples/v8\320\336\270\304\312\302\316\361\274\307\302\274.txt" "b/samples/v8\320\336\270\304\312\302\316\361\274\307\302\274.txt"
new file mode 100644
index 0000000..8c4e5c9
--- /dev/null
+++ "b/samples/v8\320\336\270\304\312\302\316\361\274\307\302\274.txt"
@@ -0,0 +1,193 @@
+用例及目标结果
+//normal   	一次
+var a = 4; var b = a ; print(a);
+
+//for    	两次
+for(var i = 1; i <= 1; i++) {print("a"); print("b") ; print("c")} print("aaa"); print("bbb")
+
+//if    	两次
+if(0){ print("a"); print("b") ; print("c"); } else {	print("c"); print("b") ; print("a"); }
+
+//while		六次
+var i = 1; while(i <= 5) { print("a"); print("b"); i++; }
+
+//do while	六次
+var i = 1; do { print("a"); print("b"); i++; }while(i <= 5)
+
+//switch	两次
+var i = 2; switch(i) { case 0: {		print("0"); print("0"); print("0"); 		break;	}case 1:{	print("1"); print("1"); print("1");  break; } default:{	print("d"); print("d"); print("d"); 		break;}}
+
+//continue	七次
+var i = 1; while(i <= 5) { if( i == 3) { i++; continue;}; print("a"); i++; }
+
+//break		四次
+var i = 1; while(i <= 5) { if( i == 3) break; i++; }
+
+
+var internal_check_time = 1; print(internal_check_time);
+
+function internal_check_time(){
+    var a = 10;
+	print(a);
+    return a;
+}
+pirntfaaaa();
+
+
+
+学习：
+1、platform 提供了线程池
+2、Isolate 提供了孤立的环境
+3、Context 提供了上下文的SHELL环境
+4、v8::Local 垃圾回收器
+5、MaybeLocalt 提供了非空的垃圾回收器
+6、ParseInfo 编译器编译配置，输入，输出的工具
+7、Zone 小的内存区块
+8、FunctionLiteral 函数名字（同时是一个ast节点）
+9、Scanner js扫描器
+10、ZoneList<Statement*>* body = new(zone()) ZoneList<Statement*>(16, zone());
+
+ParseVariableStatement
+
+
+factory()->NewExpressionStatement(expr, pos);
+
+factory()->NewConditional(expression, left, right, pos);
+
+AsmType* AsmTyper::ValidateStatement(Statement* statement) {
+  switch (statement->node_type()) {
+    default:
+      FAIL(statement, "Statement type invalid for asm.js.");
+    case AstNode::kBlock:
+      return ValidateBlockStatement(statement->AsBlock());
+    case AstNode::kExpressionStatement:
+      return ValidateExpressionStatement(statement->AsExpressionStatement());
+    case AstNode::kEmptyStatement:
+      return ValidateEmptyStatement(statement->AsEmptyStatement());
+    case AstNode::kIfStatement:
+      return ValidateIfStatement(statement->AsIfStatement());
+    case AstNode::kReturnStatement:
+      return ValidateReturnStatement(statement->AsReturnStatement());
+    case AstNode::kWhileStatement:
+      return ValidateWhileStatement(statement->AsWhileStatement());
+    case AstNode::kDoWhileStatement:
+      return ValidateDoWhileStatement(statement->AsDoWhileStatement());
+    case AstNode::kForStatement:
+      return ValidateForStatement(statement->AsForStatement());
+    case AstNode::kBreakStatement:
+      return ValidateBreakStatement(statement->AsBreakStatement());
+    case AstNode::kContinueStatement:
+      return ValidateContinueStatement(statement->AsContinueStatement());
+    case AstNode::kSwitchStatement:
+      return ValidateSwitchStatement(statement->AsSwitchStatement());
+  }
+
+  return AsmType::Void();
+}
+
+enum ScopeType : uint8_t {
+  EVAL_SCOPE,      // 0 The top-level scope for an eval source.
+  FUNCTION_SCOPE,  // 1 The top-level scope for a function.
+  MODULE_SCOPE,    // 2 The scope introduced by a module literal
+  SCRIPT_SCOPE,    // 3 The top-level scope for a script or a top-level eval.
+  CATCH_SCOPE,     // 4 The scope introduced by catch.
+  BLOCK_SCOPE,     // 5 The scope introduced by a new block.
+  WITH_SCOPE       // 6 The scope introduced by with.
+};
+
+
+
+1、用哪个v8版本测试？  PC,LINUX 都使用5.6.331
+2、接口怎么封装		   加参数 __enable_check_time__  
+3、单元测试在哪做？    v8库的demo里
+
+4、网页说的运行时脚本执行。
+	目前是在JS解析里做的，跟何时解析脚本和运行无关。
+	解析JS有两个接口：ParseOnBackground和Parse，
+	现在是在Parse里做的，ParseOnBackground外部调用 StartStreamingScript接口才会走这个流程，暂时没有修改。
+5、internal_check_time 已修改，需要在外部判断
+6、完善的单元测试用例  OK
+7、检查代码是否存在内存泄漏   13~17兆
+8、复杂和丰富的脚本检测是否存在崩溃的风险
+
+内存泄漏疑问：
+1、NewStringFromAscii
+2、new(zone()) ZoneList<Statement*>(16, zone());
+3、NewUnresolved
+4、new (zone()) ZoneList<Expression*>(1, zone());
+5、NewCall
+
+
+WIN编译：
+http://www.cnblogs.com/lzpong/p/5888289.html
+http://www.cnblogs.com/wjx0912/p/6610791.html
+set DEPOT_TOOLS_WIN_TOOLCHAIN=0
+set GYP_MSVS_VERSION=2015
+python gypfiles\gyp_v8.py -Dtarget_arch=ia32 -Dcomponent=shared_library -f msvs
+
+ubuntu 编译v8
+5.6.331
+配置 depot_tools.zip 环境变量
+
+git config --global http.proxy 'socks5://192.168.50.71:1080'
+git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
+export PATH=/home/bubi/tools/depot_tools:$PATH
+
+
+sudo apt install privoxy
+sudo service privoxy restart
+sudo vim /etc/privoxy/config
+forward-socks5 / 192.168.50.71:1080 .
+
+export http_proxy=127.0.0.1:8118  
+export https_proxy=127.0.0.1:8118
+
+gclient
+
+fetch v8
+cd v8
+
+git checkout origin/5.6.331
+gclient sync
+tools/dev/v8gen.py x64.release
+gn args out.gn/x64.release
+	is_component_build = false
+	v8_static_library = true
+
+ninja -C out.gn/x64.release
+ar cr out.gn/x64.release/obj/libv8_base.a  out.gn/x64.release/obj/v8_base/*.o
+ar cr out.gn/x64.release/obj/libv8_external_snapshot.a out.gn/x64.release/obj/v8_external_snapshot/*.o
+ar cr out.gn/x64.release/obj/libv8_libsampler.a out.gn/x64.release/obj/v8_libsampler/*.o
+ar cr out.gn/x64.release/obj/src/inspector/libinspector.a  out.gn/x64.release/obj/src/inspector/inspector/*.o
+g++ -I. -Iinclude samples/shell.cc -o shell -Wl,--start-group \
+out.gn/x64.release/obj/{libv8_{base,libbase,external_snapshot,libplatform,libsampler},\
+third_party/icu/libicu{uc,i18n},src/inspector/libinspector}.a \
+-Wl,--end-group -lrt -ldl -pthread -std=c++0x
+
+
+g++ -I. -Iinclude samples/hello-world.cc -o hello-world -Wl,--start-group \
+out.gn/x64.release/obj/{libv8_{base,libbase,external_snapshot,libplatform,libsampler},\
+third_party/icu/libicu{uc,i18n},src/inspector/libinspector}.a \
+-Wl,--end-group -lrt -ldl -pthread -std=c++0x
+
+
+
+cp out.gn/x64.release/*.bin .
+cp out.gn/x64.release/icudtl.dat .
+
+
+
+参考文档：
+http://blog.csdn.net/liaomin6t/article/details/60882598
+https://developers.google.com/v8/build
+https://github.com/v8/v8/wiki/Getting-Started-with-Embedding
+http://blog.csdn.net/tanningzhong/article/details/52817399
+https://www.bbsmax.com/A/kvJ3XBO5gM/
+https://www.jianshu.com/p/89d26429c91f
+https://github.com/v8/v8/wiki
+http://www.cnblogs.com/wjx0912/p/6610791.html
+https://stackoverflow.com/questions/15785548/manipulating-the-v8-ast
+
+
+
+
diff --git a/src/api.cc b/src/api.cc
index cfd51a3..abafc09 100644
--- a/src/api.cc
+++ b/src/api.cc
@@ -8409,6 +8409,19 @@ void Isolate::GetStackSample(const RegisterState& state, void** frames,
   sample_info->external_callback_entry = nullptr;
 }
 
+void Isolate::GetV8InternalInfo(V8InternalInfo &internal_info)
+{
+	memset(&internal_info, 0, sizeof(internal_info));
+	i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+	i::StackGuard* stack_guard = isolate->stack_guard();
+
+	uintptr_t cur = i::GetCurrentStackPosition();
+	uintptr_t real = stack_guard->real_climit();
+
+	internal_info.max_stack_size = stack_guard->get_limit_max_size();
+	internal_info.remain_stack_size = (cur - real);
+}
+
 size_t Isolate::NumberOfPhantomHandleResetsSinceLastCall() {
   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
   size_t result = isolate->global_handles()->NumberOfPhantomHandleResets();
diff --git a/src/execution.cc b/src/execution.cc
index ee6afb2..327e4be 100644
--- a/src/execution.cc
+++ b/src/execution.cc
@@ -423,6 +423,7 @@ bool StackGuard::ThreadLocal::Initialize(Isolate* isolate) {
     real_jslimit_ = SimulatorStack::JsLimitFromCLimit(isolate, limit);
     set_jslimit(SimulatorStack::JsLimitFromCLimit(isolate, limit));
     real_climit_ = limit;
+	limit_max_size_ = kLimitSize;
     set_climit(limit);
     should_set_stack_limits = true;
   }
diff --git a/src/execution.h b/src/execution.h
index d5f6371..aafd450 100644
--- a/src/execution.h
+++ b/src/execution.h
@@ -120,6 +120,11 @@ class V8_EXPORT_PRIVATE StackGuard final {
   uintptr_t real_climit() {
     return thread_local_.real_climit_;
   }
+
+  uintptr_t get_limit_max_size() {
+	  return thread_local_.limit_max_size_;
+  }
+
   uintptr_t real_jslimit() {
     return thread_local_.real_jslimit_;
   }
@@ -191,6 +196,7 @@ class V8_EXPORT_PRIVATE StackGuard final {
     // one without the real_ prefix.
     uintptr_t real_jslimit_;  // Actual JavaScript stack limit set for the VM.
     uintptr_t real_climit_;  // Actual C++ stack limit set for the VM.
+	uintptr_t limit_max_size_;
 
     // jslimit_ and climit_ can be read without any lock.
     // Writing requires the ExecutionAccess lock.
diff --git a/src/parsing/parse-info.cc b/src/parsing/parse-info.cc
index d941b8d..fe1e39c 100644
--- a/src/parsing/parse-info.cc
+++ b/src/parsing/parse-info.cc
@@ -46,7 +46,7 @@ ParseInfo::ParseInfo(Handle<SharedFunctionInfo> shared)
   isolate_ = shared->GetIsolate();
 
   set_toplevel(shared->is_toplevel());
-  set_allow_lazy_parsing(FLAG_lazy_inner_functions);
+  set_allow_lazy_parsing(false);
   set_hash_seed(isolate_->heap()->HashSeed());
   set_is_named_expression(shared->is_named_expression());
   set_calls_eval(shared->scope_info()->CallsEval());
@@ -84,6 +84,7 @@ ParseInfo::ParseInfo(Handle<Script> script)
   isolate_ = script->GetIsolate();
 
   set_allow_lazy_parsing();
+  set_allow_lazy_parsing(false);
   set_toplevel();
   set_hash_seed(isolate_->heap()->HashSeed());
   set_stack_limit(isolate_->stack_guard()->real_climit());
@@ -109,7 +110,7 @@ ParseInfo* ParseInfo::AllocateWithoutScript(Handle<SharedFunctionInfo> shared) {
   p->isolate_ = isolate;
 
   p->set_toplevel(shared->is_toplevel());
-  p->set_allow_lazy_parsing(FLAG_lazy_inner_functions);
+  p->set_allow_lazy_parsing(false);
   p->set_hash_seed(isolate->heap()->HashSeed());
   p->set_is_named_expression(shared->is_named_expression());
   p->set_calls_eval(shared->scope_info()->CallsEval());
diff --git a/src/parsing/parser.cc b/src/parsing/parser.cc
index 86c7f1b..9d89aba 100644
--- a/src/parsing/parser.cc
+++ b/src/parsing/parser.cc
@@ -25,6 +25,14 @@
 #include "src/string-stream.h"
 #include "src/tracing/trace-event.h"
 
+#if 0
+#define LOG_INFO printf
+#else
+void no_printf(const char* format, ...) {}
+#define LOG_INFO no_printf
+#endif
+
+
 namespace v8 {
 namespace internal {
 
@@ -3416,6 +3424,246 @@ void Parser::UpdateStatistics(Isolate* isolate, Handle<Script> script) {
   }
 }
 
+void Parser::UpdateCallList(ParseInfo* info)
+{
+	if (info == nullptr)
+	{
+		return;
+	}
+
+	FunctionLiteral* function = info->literal();
+	if (function == nullptr)
+	{
+		return;
+	}
+	Handle<Script> script = info->script();
+	String* script_name = script->name()->IsString()
+		? String::cast(script->name())
+		: info->isolate()->heap()->empty_string();
+
+	if (script_name == nullptr)
+	{
+		return;
+	}
+
+	//NewStringFromStaticChars, isolate delete memory
+	Handle<String> check_string_name = info->isolate()->factory()->NewStringFromStaticChars("__enable_check_time__");
+	if (!check_string_name->Equals(script_name))
+	{
+		return;
+	}
+
+	DCHECK_NOT_NULL(function);
+	Scope* scope = function->scope();
+	DCHECK_NOT_NULL(scope);
+
+	if (!scope->is_script_scope() && !scope->is_eval_scope() && !scope->is_function_scope())
+	{
+		LOG_INFO("v8-unkown script scope:%d\n", scope->scope_type());
+		return;
+	}
+
+	gloal_factory_.ast_value_factory_ = info->ast_value_factory();
+	gloal_factory_.info_zone_ = info->zone();
+	gloal_factory_.isolate_factory_ = info->isolate()->factory();
+	gloal_factory_.scope_ = scope;
+
+	VisitWithStatementList(function->body());
+}
+
+void Parser::VisitWithBlock(Block* block)
+{
+	if (!IsValidBlock(block))
+	{
+		return;
+	}
+
+	VisitWithStatementList(block->statements());
+}
+
+void Parser::VisitWithStatementList(ZoneList<Statement*>* statement_list)
+{
+	LOG_INFO("VisitWithBlock In, list len:%d, capacity:%d\n", statement_list->length(), statement_list->capacity());
+	if (statement_list == nullptr || statement_list->capacity() <= 0 || statement_list->length() < 0)
+	{
+		return;
+	}
+
+	for (int i = 0; i < statement_list->length(); i++)
+	{
+		Statement* stmt = statement_list->at(i);
+		if (!IsValidBlock((BlockT)stmt))
+		{
+			continue;
+		}
+		AstNode::NodeType note_type = stmt->node_type();
+		LOG_INFO("VisitWithStatementList statement note_type:%d\n", (int)note_type);
+		switch (note_type)
+		{
+		case AstNode::kBlock:
+		{
+			Block* body = stmt->AsBlock();
+			if (!IsValidBlock(body))
+			{
+				LOG_INFO("v8 invalid kBlock\n");
+				break;
+			}
+
+			if (body->ignore_completion_value())
+			{
+				break;
+			}
+
+			if (body->statements()->length() > 1)
+			{
+				VisitWithBlock(body);
+			}
+			break;
+		}
+		case AstNode::kIfStatement:
+		{
+			IfStatement *if_stmt = (IfStatement*)stmt;
+			IterateReplaceIfstateNode(if_stmt);
+			break;
+		}
+		case AstNode::kWhileStatement:
+		case AstNode::kDoWhileStatement:
+		case AstNode::kForStatement:
+		case AstNode::kForInStatement:
+		case AstNode::kForOfStatement:
+		{
+			VisitWithBlock((BlockT)((IterationStatement*)stmt)->body());
+			break;
+		}
+		case AstNode::kTryCatchStatement:
+		{
+			VisitWithBlock((BlockT)((TryCatchStatement*)stmt)->try_block());
+			VisitWithBlock((BlockT)((TryCatchStatement*)stmt)->catch_block());
+			break;
+		}
+		case AstNode::kTryFinallyStatement:
+		{
+			VisitWithBlock((BlockT)((TryFinallyStatement*)stmt)->try_block());
+			VisitWithBlock((BlockT)((TryFinallyStatement*)stmt)->finally_block());
+			break;
+		}
+		case AstNode::kSwitchStatement:
+		{
+			ZoneList<CaseClause*>* cases = ((SwitchStatement*)stmt)->cases();
+			for (int i = 0; i < cases->length(); i++)
+			{
+				VisitWithBlock((BlockT)(cases->at(i)));
+			}
+			break;
+		}
+		case AstNode::kWithStatement:
+		{
+			VisitWithBlock((BlockT)((WithStatement*)stmt)->statement());
+			break;
+		}
+		case AstNode::kSloppyBlockFunctionStatement:
+		{
+			VisitWithBlock((BlockT)((SloppyBlockFunctionStatement*)stmt)->statement());
+			break;
+		}
+		case AstNode::kExpressionStatement:
+		case AstNode::kEmptyStatement:
+		case AstNode::kReturnStatement:
+		case AstNode::kBreakStatement:
+		case AstNode::kContinueStatement:
+		{
+			LOG_INFO("v8 ignore node type: %d\n", note_type);
+			break;
+		}
+		default:
+		{
+			LOG_INFO("v8 default astnote type: %d\n", note_type);
+			break;
+		}
+		}
+	}
+
+	PushStatementList(statement_list);
+}
+
+void Parser::IterateReplaceIfstateNode(Statement* stmt)
+{
+	IfStatement *if_stmt = (IfStatement*)stmt;
+	//then body
+	if (if_stmt->HasThenStatement())
+	{
+		VisitWithBlock((BlockT)if_stmt->then_statement());
+	}
+
+	if (if_stmt->HasElseStatement())
+	{
+		//else body
+		BlockT body = (BlockT)if_stmt->else_statement();
+		if (body->IsIfStatement())
+		{
+			IterateReplaceIfstateNode(body);
+		}
+		else if (IsValidBlock(body))
+		{
+			VisitWithBlock(body);
+		}
+	}
+}
+
+void Parser::PushStatementList(ZoneList<Statement*>* statements)
+{
+	ZoneList<Statement*>* new_statement_list = new(zone()) ZoneList<Statement*>(16, zone());
+	//LOG_INFO("before PushNewStatement:%d\n", result_statements->length());
+	bool is_first = true;
+	if (!statements->is_empty())
+	{
+		for (int i = 0; i < statements->length(); i++)
+		{
+			PushStatementObj(new_statement_list, is_first);
+			new_statement_list->Add(statements->at(i), zone());
+			is_first = false;
+		}
+	}
+	else
+	{
+		PushStatementObj(new_statement_list, is_first);
+	}
+
+	statements->Clear();
+	statements->AddAll(new_statement_list->ToVector(), zone());
+	//LOG_INFO("after PushNewStatement:%d\n", result_statements->length());
+}
+
+void Parser::PushStatementObj(ZoneList<Statement*>* statements, bool is_block_first)
+{
+	Handle<String> func_string_name = gloal_factory_.isolate_factory_->NewStringFromStaticChars("internal_check_time");
+	const AstRawString* func_name_string = gloal_factory_.ast_value_factory_->GetString(func_string_name);
+	DCHECK(func_name_string != nullptr);
+	VariableProxy* function_proxy = gloal_factory_.scope_->NewUnresolved(factory(), func_name_string);
+
+	ZoneList<Expression*>* args = new (zone()) ZoneList<Expression*>(1, zone());
+	Literal* msg = factory()->NewBooleanLiteral(is_block_first, 0);
+	args->Add(msg, gloal_factory_.info_zone_);
+	statements->Add(factory()->NewExpressionStatement(factory()->NewCall(function_proxy, args, 0), 0), zone());
+}
+
+bool Parser::IsValidBlock(BlockT block)
+{
+	if (block == nullptr)
+	{
+		return false;
+	}
+
+	if (block->IsEmptyStatement() || block->IsEmpty() || block->IsExpressionStatement()
+		|| block->IsReturnStatement() || block->IsAssignment() || block->IsBreakStatement()
+		|| block->IsExpressionStatement() || block->IsContinueStatement())
+	{
+		return false;
+	}
+
+	return true;
+}
+
 void Parser::ParseOnBackground(ParseInfo* info) {
   parsing_on_main_thread_ = false;
 
diff --git a/src/parsing/parser.h b/src/parsing/parser.h
index 4892f76..c616611 100644
--- a/src/parsing/parser.h
+++ b/src/parsing/parser.h
@@ -227,12 +227,38 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   void UpdateStatistics(Isolate* isolate, Handle<Script> script);
   void HandleSourceURLComments(Isolate* isolate, Handle<Script> script);
 
+  void UpdateCallList(ParseInfo* info);
+  void VisitWithBlock(Block* block);
+  void VisitWithStatementList(ZoneList<Statement*>* statement_list);
+  void PushStatementList(ZoneList<Statement*>* statements);
+  void PushStatementObj(ZoneList<Statement*>* statements, bool is_block_first);
+  bool IsValidBlock(BlockT block);
+  void IterateReplaceIfstateNode(Statement* stmt);
+
  private:
   friend class ParserBase<Parser>;
   friend class v8::internal::ExpressionClassifier<ParserTypes<Parser>>;
   friend bool v8::internal::parsing::ParseProgram(ParseInfo*, bool);
   friend bool v8::internal::parsing::ParseFunction(ParseInfo*, bool);
 
+  typedef struct tagGlobalFactory
+  {
+	  Factory* isolate_factory_;
+	  AstValueFactory* ast_value_factory_;
+	  Scope* scope_;
+	  Zone* info_zone_;
+
+	  tagGlobalFactory()
+	  {
+		  isolate_factory_ = nullptr;
+		  ast_value_factory_ = nullptr;
+		  scope_ = nullptr;
+		  info_zone_ = nullptr;
+	  }
+  }GlobalFactory;
+
+  GlobalFactory gloal_factory_;
+
   bool AllowsLazyParsingWithoutUnresolvedVariables() const {
     return scope()->AllowsLazyParsingWithoutUnresolvedVariables(
         original_scope_);
diff --git a/src/parsing/parsing.cc b/src/parsing/parsing.cc
index ede13ac..0517193 100644
--- a/src/parsing/parsing.cc
+++ b/src/parsing/parsing.cc
@@ -34,7 +34,11 @@ bool ParseProgram(ParseInfo* info, bool internalize) {
   } else {
     info->set_language_mode(info->literal()->language_mode());
   }
+
+  parser.UpdateCallList(info);
+
   parser.UpdateStatistics(isolate, info->script());
+
   if (internalize) {
     info->ast_value_factory()->Internalize(isolate);
   }
@@ -57,7 +61,11 @@ bool ParseFunction(ParseInfo* info, bool internalize) {
   if (result == nullptr) {
     parser.ReportErrors(isolate, info->script());
   }
+
+  parser.UpdateCallList(info);
+
   parser.UpdateStatistics(isolate, info->script());
+
   if (internalize) {
     info->ast_value_factory()->Internalize(isolate);
   }
